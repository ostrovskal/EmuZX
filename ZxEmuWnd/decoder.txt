#if defined BIGENDIAN
typedef union {
	struct { unsigned char h,  l; } b;
	struct { unsigned short w; }w;
} regpair;
#endif

typedef struct {
	regpair af,bc,de,hl;
	regpair af_,bc_,de_,hl_;
	regpair ix,iy;
	unsigned char i,r,r7; 
	regpair sp,pc;
	unsigned char iff1,iff2, im;
	int halted;
} processor;

processor pz80;

#define IFF1 pz80.iff1
#define IFF2 pz80.iff2
#define IM pz80.im
#define halted pz80.halted
#define interrupts pz80.iff1

#define A   pz80.af.b.h
#define F   pz80.af.b.l
#define AF  pz80.af.w.w

#define B   pz80.bc.b.h
#define C   pz80.bc.b.l
#define BC  pz80.bc.w.w

#define D   pz80.de.b.h
#define E   pz80.de.b.l
#define DE  pz80.de.w.w

#define H   pz80.hl.b.h
#define L   pz80.hl.b.l
#define HL  pz80.hl.w.w

#define A_  pz80.af_.b.h
#define A1  pz80.af_.b.h
#define F_  pz80.af_.b.l
#define F1  pz80.af_.b.l
#define AF_ pz80.af_.w.w

#define B_  pz80.bc_.b.h
#define B1  pz80.bc_.b.h
#define C_  pz80.bc_.b.l
#define C1  pz80.bc_.b.l
#define BC_ pz80.bc_.w.w

#define D_  pz80.de_.b.h.
#define D1  pz80.de_.b.h
#define E_  pz80.de_.b.l
#define E1  pz80.de_.b.l
#define DE_ pz80.de_.w.w

#define H_  pz80.hl_.b.h
#define H1  pz80.hl_.b.h
#define L_  pz80.hl_.b.l
#define L1  pz80.hl_.b.l
#define HL_ pz80.hl_.w.w

#define IXH pz80.ix.b.h
#define IXL pz80.ix.b.l
#define IXh pz80.ix.b.h
#define IXl pz80.ix.b.l
#define IX  pz80.ix.w.w

#define IYH pz80.iy.b.h
#define IYL pz80.iy.b.l
#define IYh pz80.iy.b.h
#define IYl pz80.iy.b.l
#define IY  pz80.iy.w.w

#define SPH pz80.sp.b.h
#define SPL pz80.sp.b.l
#define SP  pz80.sp.w.w

#define PCH pz80.pc.b.h
#define PCL pz80.pc.b.l
#define PC  pz80.pc.w.w

#define I  pz80.i
#define R  pz80.r
#define R7 pz80.r7

int z80a(int interrupt)
{
#if defined log
	PrintSpInfo();
	interrupt=0;	
#endif

	R++;

	if (interrupt)
	{
		if (interrupts)
		{
			interrupts=off;
			halted=off;

			switch(IM)
			{
			case 1: 
				{
					push(PC);
					PC=0x0038;

					return(13);
				}

			case 2: 
				{
					push(PC);
					io_writeToRamAddrSpAddr((unsigned char *)&PC, I*256+data_bus);

					return(19);
				}

			case 0:
				{
					if (data_bus==255)
					{
						push(PC);
						PC=0x0038;

						return(12);
					}
					else
					{
						printf("data_bus == %d. This is not supported.",data_bus);
						ExitWithError(-1,"");
					}
					/* !!! a vot tuta ne dodelano*/
				}

			default:
				{
					printf("Unknown interrupts type %d.\n",IM);
					ExitWithError(-1,"");
				}
			}
		}
	}

	if (halted)
		return(4);

	if (PC>=16384)
		TRDOS=off;
	else
	{
		if (((PC&0xff00)==0x3d00))
		{
			if (new_rom!=ROM0) 
			{
				if ((Mode[0]=='P')||(Mode[0]=='p')||(Mode[0]=='S')||(Mode[0]=='s'))
					TRDOS=on;
			}
		}

		if ((PC==1218)&&(!TRDOS)) 
		{
			TapeTrapSave();
			pop(&PC);
			return(4);
		}


		//if (PC==1366)
		//{
			//SaveZ80("TLoad48.z80");
		//}

		if (((PC==1366)||(PC==1378)) && tape_traps && tape_next) 
		{
			if ((tape_pos<tape_len) && (tape_next->id!=0x15) && (DE!=tape_next->len-2))
			{
				//printf ("stop \n");
				tape_stopF(0, 0, 0);
			}

			//printf ("%d %d \n", DE, tape_next->len-2);

			if (DE==tape_next->len-2)
			{
				TapeTrapLoad();
				PC=0x5e2;
				return(4);
			}
			else
				 tapeFill_tape(1);
		}

		if (PC==1366 && !tape_traps)
		{
			if (tape_pos>=tape_len) tapeFill_tape(1);
		}
	}

	switch(io_readByte(PC))
	{
		/* interrupts*/

	case 0xf3: /* di */
		{
			interrupts=off; 
			PC++;
			return(4);
		}


	case 0xfb: /* ei */
		{
			/* #if !defined log */
			interrupts=on;
			/* #endif*/
			PC++;
			return(4);
		}

		/* zagruzka chisla v registr */

	case 0x3e:
		{
			A=io_readByte(PC+1);
			PC+=2;
			return(7);
		}

	case 0x06:
		{
			B=io_readByte(PC+1);
			PC+=2;
			return(7);
		}

	case 0x0e:
		{
			C=io_readByte(PC+1);
			PC+=2;
			return(7);
		}

	case 0x16:
		{
			D=io_readByte(PC+1);
			PC+=2;
			return(7);
		}

	case 0x1e:
		{
			E=io_readByte(PC+1);
			PC+=2;
			return(7);
		}

	case 0x26:
		{
			H=io_readByte(PC+1);
			PC+=2;
			return(7);
		}

	case 0x2e:
		{
			L=io_readByte(PC+1);
			PC+=2;
			return(7);
		}

		/* zagruzka chisla v registrovuu paru */

	case 0x21:
		{
			L=io_readByte(PC+1);

			H=io_readByte(PC+2);
			PC+=3;
			return(10);
		}

	case 0x11:
		{
			E=io_readByte(PC+1);
			D=io_readByte(PC+2);
			PC+=3;
			return(10);
		}

	case 0x01:
		{
			C=io_readByte(PC+1);
			B=io_readByte(PC+2);
			PC+=3;
			return(10);
		}

	case 0x31:
		{
			io_writeToRamAddrSpAddr((unsigned char *)&SP, PC+1);
			PC+=3;
			return(10);
		}

		/* Kopirovanie soderjimogo odinochnih registrov */

	case 0x7f:
		{
			A=A;
			PC++;
			return(4);
		}

	case 0x7c:
		{
			A=H;
			PC++;
			return(4);
		}

	case 0x7d:
		{
			A=L;
			PC++;
			return(4);
		}

	case 0x78:
		{
			A=B;
			PC++;
			return(4);
		}

	case 0x79:
		{
			A=C;
			PC++;
			return(4);

		}

	case 0x7a:
		{
			A=D;
			PC++;
			return(4);
		}

	case 0x7b:

		{
			A=E;
			PC++;
			return(4);
		}

	case 0x67:
		{
			H=A;
			PC++;
			return(4);
		}

	case 0x64:
		{
			H=H;
			PC++;
			return(4);
		}

	case 0x65:
		{
			H=L;
			PC++;
			return(4);
		}

	case 0x60:
		{
			H=B;
			PC++;
			return(4);
		}

	case 0x61:
		{
			H=C;
			PC++;

			return(4);
		}

	case 0x62:

		{
			H=D;
			PC++;
			return(4);
		}

	case 0x63:
		{
			H=E;
			PC++;
			return(4);
		}

	case 0x6f:
		{
			L=A;
			PC++;
			return(4);

		}

	case 0x6c:
		{
			L=H;

			PC++;
			return(4);
		}

	case 0x6d:
		{
			L=L;
			PC++;
			return(4);
		}

	case 0x68:
		{
			L=B;
			PC++;

			return(4);
		}


	case 0x69:
		{
			L=C;
			PC++;
			return(4);
		}

	case 0x6a:
		{
			L=D;
			PC++;
			return(4);
		}

	case 0x6b:
		{
			L=E;
			PC++;
			return(4);
		}

	case 0x47:

		{
			B=A;
			PC++;
			return(4);
		}

	case 0x44:
		{
			B=H;
			PC++;
			return(4);
		}

	case 0x45:
		{
			B=L;
			PC++;
			return(4);
		}

	case 0x40:
		{
			B=B;
			PC++;
			return(4);
		}

	case 0x41:
		{
			B=C;
			PC++;
			return(4);
		}



	case 0x42:

		{
			B=D;
			PC++;
			return(4);
		}

	case 0x43:
		{
			B=E;
			PC++;
			return(4);
		}

	case 0x4f:
		{
			C=A;
			PC++;
			return(4);
		}

	case 0x4c:
		{
			C=H;
			PC++;
			return(4);
		}

	case 0x4d:
		{
			C=L;
			PC++;
			return(4);
		}

	case 0x48:
		{
			C=B;
			PC++;
			return(4);
		}

	case 0x49:
		{
			C=C;
			PC++;
			return(4);
		}


	case 0x4a:
		{
			C=D;
			PC++;
			return(4);
		}

	case 0x4b:
		{
			C=E;
			PC++;
			return(4);
		}

	case 0x57:
		{
			D=A;
			PC++;
			return(4);
		}

	case 0x54:
		{
			D=H;
			PC++;
			return(4);
		}

	case 0x55:
		{
			D=L;
			PC++;
			return(4);
		}

	case 0x50:
		{
			D=B;
			PC++;
			return(4);
		}

	case 0x51:
		{
			D=C;
			PC++;
			return(4);
		}

	case 0x52:
		{
			D=D;
			PC++;
			return(4);
		}

	case 0x53:
		{
			D=E;
			PC++;
			return(4);
		}

	case 0x5f:
		{
			E=A;
			PC++;
			return(4);
		}

	case 0x5c:
		{
			E=H;
			PC++;
			return(4);
		}

	case 0x5d:
		{
			E=L;
			PC++;
			return(4);
		}

	case 0x58:
		{
			E=B;
			PC++;
			return(4);
		}

	case 0x59:
		{
			E=C;
			PC++;
			return(4);
		}

	case 0x5a:
		{
			E=D;
			PC++;
			return(4);
		}

	case 0x5b:
		{
			E=E;
			PC++;
			return(4);
		}

		/* kopirovanie soderjimogo registrovih par */

	case 0xf9:
		{
			SP=HL;
			PC++;
			return(6);
		}

		/* zagruzka registrov iz pamyati pryamoy adresitsiei */

	case 0x3a:
		{
			A=io_readByte(ex(io_readByte(PC+2), io_readByte(PC+1)));
			PC+=3;
			return(13);
		}

	case 0x2a:
		{
			L=io_readByte(ex(io_readByte(PC+2), io_readByte(PC+1)));
			H=io_readByte(ex(io_readByte(PC+2), io_readByte(PC+1))+1);

			PC+=3;
			return(16);
		}

		/* zagruzka registrov iz pamyati kosvennoy adresatsiei */

	case 0x7e:

		{
			A=io_readByte(HL);
			PC++;
			return(7);
		}

	case 0x0a:
		{
			A=io_readByte(BC);
			PC++;
			return(7);
		}

	case 0x1a:
		{

			A=io_readByte(DE);
			PC++;
			return(7);
		}

	case 0x66:

		{

			H=io_readByte(HL);
			PC++;
			return(7);
		}

	case 0x6e:
		{
			L=io_readByte(HL);
			PC++;
			return(7);
		}

	case 0x46:
		{
			B=io_readByte(HL);
			PC++;
			return(7);
		}

	case 0x4e:
		{
			C=io_readByte(HL);
			PC++;
			return(7);
		}

	case 0x56:
		{
			D=io_readByte(HL);
			PC++;
			return(7);
		}

	case 0x5e:
		{
			E=io_readByte(HL);
			PC++;
			return(7);
		}

		/* 	komandi obmena */

	case 0xeb:
		{
			D2=D; E2=E;
			D=H; E=L;
			H=D2; L=E2;
			PC++;
			return(4);
		}	

	case 0xd9:
		{
			B2=B; C2=C; D2=D; E2=E; H2=H; L2=L;
			B=B1; C=C1; D=D1; E=E1; H=H1; L=L1;
			B1=B2; C1=C2; D1=D2; E1=E2; H1=H2; L1=L2;

			PC++;
			return(4);
		}	


	case 0x08:
		{
			A2=A; F2=F; 

			A=A1; F=F1; 
			A1=A2; F1=F2; 

			PC++;
			return(4);
		}	

		/* zapis' v pamyat' pryamoi adresatsiei */

	case 0x32:
		{
			io_writeByte(ex(io_readByte(PC+2),io_readByte(PC+1)),A);
			PC+=3;
			return(13);
		}

	case 0x22:
		{
			io_writeByte(ex(io_readByte(PC+2),io_readByte(PC+1)),L);
			io_writeByte(ex(io_readByte(PC+2),io_readByte(PC+1))+1,H);

			PC+=3;
			return(16);
		}	

		/* Zapis' v pamyat' s kosvennoi adresatsiei */

	case 0x77:
		{
			io_writeByte(HL,A);
			PC++;
			return(7);
		}


	case 0x02:
		{
			io_writeByte(BC,A);
			PC++;
			return(7);
		}

	case 0x12:
		{
			io_writeByte(DE,A);
			PC++;
			return(7);
		}

	case 0x74:
		{

			io_writeByte(HL,H);
			PC++;
			return(7);
		}

	case 0x75:
		{
			io_writeByte(HL,L);
			PC++;
			return(7);
		}

	case 0x70:
		{
			io_writeByte(HL,B);
			PC++;
			return(7);
		}

	case 0x71:
		{
			io_writeByte(HL,C);
			PC++;
			return(7);
		}


	case 0x72:
		{
			io_writeByte(HL,D);
			PC++;
			return(7);
		}

	case 0x73:
		{
			io_writeByte(HL,E);
			PC++;
			return(7);
		}

	case 0x36:
		{
			io_writeByte(HL,io_readByte(PC+1));

			PC+=2;
			return(10);
		}	


		/* komandi logiki */

		/*  AND	*/
	case 0xe6:
		{
			A=A&io_readByte(PC+1);

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC+=2;
			return(7);
		}	

	case 0xa7:
		{
			A=A&A;



			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xa4:
		{
			A=A&H;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xa5:
		{
			A=A&L;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xa0:
		{
			A=A&B;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xa1:
		{
			A=A&C;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xa2:
		{
			A=A&D;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	


	case 0xa3:
		{
			A=A&E;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xa6:
		{
			A=A&(io_readByte(HL));

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(7);
		}	

		/* OR */
	case 0xf6:
		{
			A=A|io_readByte(PC+1);

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC+=2;
			return(7);
		}	

	case 0xb7:
		{
			A=A|A;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xb4:
		{
			A=A|H;





			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xb5:
		{
			A=A|L;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xb0:
		{
			A=A|B;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xb1:
		{
			A=A|C;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;

			return(4);
		}	

	case 0xb2:
		{
			A=A|D;

			ParityA;
			ZnakA;

			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xb3:
		{
			A=A|E;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xb6:
		{
			A=A|(io_readByte(HL));

			ParityA;

			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);

			myFflagN_s(0);

			PC++;
			return(7);
		}

		/* XOR */
	case 0xee:

		{
			A=A^io_readByte(PC+1);


			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC+=2;
			return(7);
		}	

	case 0xaf:

		{
			A=A^A;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xac:
		{
			A=A^H;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xad:
		{
			A=A^L;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);

			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xa8:

		{
			A=A^B;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);

			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xa9:
		{
			A=A^C;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xaa:
		{
			A=A^D;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);



			PC++;
			return(4);

		}	

	case 0xab:
		{
			A=A^E;


			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}	

	case 0xae:
		{
			A=A^(io_readByte(HL));

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(7);
		}


		/* komandi perehoda */

	case 0xc3:
		{
			io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
			return(10);
		}

	case 0xe9:
		{
			PC=HL;
			return(4);
		}

	case 0xda:
		{
			if (myFflagC_r())
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
			else
				PC+=3;

			return(10);
		}

	case 0xd2:
		{
			if (!myFflagC_r())
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
			else
				PC+=3;

			return(10);
		}

	case 0xca:
		{
			if (F&64)
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
			else
				PC+=3;

			return(10);
		}

	case 0xc2:
		{
			if (!(F&64))
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
			else
				PC+=3;

			return(10);
		}

	case 0xf2:
		{
			if (!(F&128))
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
			else
				PC+=3;

			return(10);
		}

	case 0xfa:
		{
			if (F&128)
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
			else
				PC+=3;

			return(10);
		}

	case 0xea:
		{
			if (F&4)
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
			else
				PC+=3;

			return(10);

		}

	case 0xe2:
		{
			if (!(F&4))
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
			else
				PC+=3;

			return(10);
		}

	case 0x18:
		{
			PC+=(signed char)io_readByte(PC+1);
			PC+=2;

			return(12); 
		}

	case 0x38:
		{
			if (myFflagC_r())
			{
				PC+=(signed char)io_readByte(PC+1);
				PC+=2;
				return(12); 
			}
			else
			{
				PC+=2;
				return(7); 
			}
		}

	case 0x30:
		{
			if (!myFflagC_r())


			{
				PC+=(signed char)io_readByte(PC+1);
				PC+=2;
				return(12); 
			}
			else
			{
				PC+=2;
				return(7); 
			}
		}	

	case 0x28:
		{
			if (F&64)
			{
				PC+=(signed char)io_readByte(PC+1);
				PC+=2;
				return(12); 
			}
			else
			{
				PC+=2;
				return(7); 
			}
		}

	case 0x20:
		{
			if (!(F&64))
			{
				PC+=(signed char)io_readByte(PC+1);
				PC+=2;
				return(12); 
			}
			else
			{
				PC+=2;
				return(7); 
			}
		}

	case 0x10: /* djnz */
		{
			B--;
			if (B!=0)
			{
				PC+=(signed char)io_readByte(PC+1);
				PC+=2;
				return(13);
			}
			else
			{
				PC+=2;
				return(8); 
			}
		}

		/* Decrement */

	case 0x0d:
		{
			C--;

			znak(C);
			zero(C);
			myFflagPV_s((C==0x7f));
			myFflagN_s(1);
			myFflagH_s(    ((C & 0x0f) == 0x0f));

			PC++;
			return(4);
		}	

	case 0x3d:
		{
			A--;

			znak(A);
			zero(A);
			myFflagPV_s((A==0x7f));
			myFflagN_s(1);
			myFflagH_s(    ((A&0x0f)==0x0f));

			PC++;
			return(4);
		}

	case 0x25:
		{
			H--;

			znak(H);
			zero(H);
			myFflagPV_s((H==0x7f));
			myFflagN_s(1);
			myFflagH_s(    ((H&0x0f)==0x0f));

			PC++;
			return(4);
		}

	case 0x2d:
		{
			L--;

			znak(L);
			zero(L);
			myFflagPV_s((L==0x7f));
			myFflagN_s(1);
			myFflagH_s(    ((L&0x0f)==0x0f));

			PC++;
			return(4);
		}

	case 0x05:
		{
			B--;

			znak(B);
			zero(B);
			myFflagPV_s((B==0x7f));
			myFflagN_s(1);
			myFflagH_s(    ((B&0x0f)==0x0f));

			PC++;
			return(4);
		}

	case 0x1d:
		{
			E--;


			znak(E);
			zero(E);
			myFflagPV_s((E==0x7f));
			myFflagN_s(1);
			myFflagH_s(    ((E&0x0f)==0x0f));

			PC++;
			return(7);
		}

	case 0x15:
		{
			D--;

			znak(D);
			zero(D);
			myFflagPV_s((D==0x7f));
			myFflagN_s(1);
			myFflagH_s(    ((D&0x0f)==0x0f));

			PC++;
			return(7);

		}

	case 0x35:
		{
			work8=io_readByte(HL);
			work8--;
			io_writeByte(HL,work8);

			znak(io_readByte(HL));
			zero(io_readByte(HL));
			myFflagPV_s((io_readByte(HL)==0x7f));
			myFflagN_s(1);
			myFflagH_s(    ((io_readByte(HL)&0x0f)==0x0f));

			PC++;
			return(11);
		}

	case 0x2b:
		{	
			HL--;

			PC++;
			return(6);
		}

	case 0x0b:
		{	
			BC--;

			PC++;
			return(6);

		}

	case 0x1b:
		{	
			DE--;

			PC++;
			return(6);
		}

	case 0x3b:
		{	
			SP--;
			PC++;
			return(6);
		}

		/* komandi sravnenia	*/


	case 0xbf:
		{	
			val=A;

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) | (((val) & 0x88) >> 2) | ((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0xbc:
		{	
			val=H;

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0xbd:
		{	
			val=L;

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0xb8:
		{	
			val=B;

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0xb9:
		{	
			val=C;

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    

			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0xba:
		{	
			val=D;

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));


			PC++;
			return(4);
		}

	case 0xbb:
		{	
			val=E;

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);

		}

	case 0xfe:
		{	
			val=io_readByte(PC+1);

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       

				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                

			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC+=2;
			return(7);
		}

	case 0xbe:
		{	
			val=io_readByte(HL);

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               

				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(7);
		}

		/* vichitanie s uchetom perenosa */

	case 0xde:
		{
			val=io_readByte(PC+1);

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC+=2;

			return(7);
		}

	case 0x9f:

		{
			val=A;

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x9c:
		{

			val=H;

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x9d:
		{
			val=L;

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x98:
		{
			val=B;

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x99:
		{
			val=C;

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}


	case 0x9a:
		{
			val=D;

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x9b:
		{
			val=E;

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x9e:
		{
			val=io_readByte(HL);

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));


			PC++;
			return(7);
		}

		/* komandi prostogo slojeniya	*/

	case 0x87:
		{
			val=A;

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));



			PC++;
			return(4);
		}

	case 0x84:
		{
			val=H;

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(4);
		}

	case 0x85:
		{
			val=L;

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(4);
		}

	case 0x80:
		{
			val=B;

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );


			PC++;
			return(4);
		}

	case 0x81:
		{
			val=C;

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(4);
		}

	case 0x82:
		{
			val=D;

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              

			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(4);
		}

	case 0x83:
		{
			val=E;

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(4);
		}


	case 0xc6:
		{
			val=io_readByte(PC+1);

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC+=2;
			return(7);
		}

	case 0x86:
		{
			val=io_readByte(HL);

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(7);
		}

	case 0x29:
		{
			reg=HL;

			work32 = HL + reg;                                                                    
			idx = ((HL & 0x8800) >> 9) |                                                    
				(((reg) & 0x8800) >> 10) |                                            
				((work32 & 0x8800) >> 11);                                            
			HL1_1 = work32 & 0xffff;       

			//printf("%d %d\n", idx, hcarry_tbl(idx));

			myFflagH_s(   hcarry_tbl(idx));                                                               

			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work32 & 0x10000) != 0));
			HL=HL1_1;


			PC++;
			return(11);
		}

	case 0x09:
		{
			reg=BC;

			work32 = HL + reg;                                                                    
			idx = ((HL & 0x8800) >> 9) |                                                    
				(((reg) & 0x8800) >> 10) |                                            
				((work32 & 0x8800) >> 11);                                            
			HL1_1 = work32 & 0xffff;                                                                   

			myFflagH_s(   hcarry_tbl(idx));                                                               
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work32 & 0x10000) != 0) );
			HL=HL1_1;

			PC++;
			return(11);
		}

	case 0x19:
		{
			reg=DE;

			work32 = HL + reg;                                                                    
			idx = ((HL & 0x8800) >> 9) |                                                    
				(((reg) & 0x8800) >> 10) |                                            
				((work32 & 0x8800) >> 11);                                            
			HL1_1 = work32 & 0xffff;                                                                   
			myFflagH_s(   hcarry_tbl(idx));                                                               
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work32 & 0x10000) != 0) );

			HL=HL1_1;

			PC++;
			return(11);
		}

	case 0x39:
		{
			reg=SP;

			work32 = HL + reg;                                                                    
			idx = ((HL & 0x8800) >> 9) |                                                    
				(((reg) & 0x8800) >> 10) |                                            
				((work32 & 0x8800) >> 11);                                            
			HL1_1 = work32 & 0xffff;                                                                   
			myFflagH_s(   hcarry_tbl(idx));                                                               
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work32 & 0x10000) != 0) );
			HL=HL1_1;

			PC++;
			return(11);
		}



		/* increment */

	case 0x3c :
		{
			reg=A;


			reg++;                                                                                                
			znak(reg);                                                 
			zero(reg);                                                                  
			myFflagH_s(   (((reg) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((reg) == 0x80));                                                               
			myFflagN_s(0);
			A=reg;

			PC++;
			return(4);
		}

	case 0x24 :
		{
			reg=H;

			reg++;                                                                                                
			znak(reg);                                                 
			zero(reg);                                                                  
			myFflagH_s(   (((reg) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((reg) == 0x80));                                                               
			myFflagN_s(0);
			H=reg;

			PC++;
			return(4);
		}

	case 0x2c :
		{
			reg=L;

			reg++;                                                                                                
			znak(reg);                                                 
			zero(reg);                                                                  
			myFflagH_s(   (((reg) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((reg) == 0x80));                                                               

			myFflagN_s(0);
			L=reg;

			PC++;
			return(4);
		}

	case 0x04 :
		{
			reg=B;


			reg++;                                                                                                
			znak(reg);                                                 
			zero(reg);                                                                  
			myFflagH_s(   (((reg) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((reg) == 0x80));                                                               
			myFflagN_s(0);
			B=reg;

			PC++;
			return(4);
		}

	case 0x0c :
		{
			reg=C;

			reg++;                                                                                                
			znak(reg);                                                 
			zero(reg);                                                                  
			myFflagH_s(   (((reg) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((reg) == 0x80));                                                               
			myFflagN_s(0);
			C=reg;

			PC++;
			return(4);
		}

	case 0x14 :
		{
			reg=D;

			reg++;                                                                                                
			znak(reg);                                                 
			zero(reg);                                                                  
			myFflagH_s(   (((reg) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((reg) == 0x80));                                                               
			myFflagN_s(0);
			D=reg;

			PC++;
			return(4);
		}

	case 0x1c :
		{
			reg=E;

			reg++;                                                                                                
			znak(reg);                                                 
			zero(reg);                                                                  
			myFflagH_s(   (((reg) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((reg) == 0x80));                                                               
			myFflagN_s(0);
			E=reg;

			PC++;
			return(4);
		}

	case 0x34 :
		{
			reg=io_readByte(HL);

			reg++;                                                                                                
			znak(reg);                                                 
			zero(reg);                                                                  
			myFflagH_s(   (((reg) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((reg) == 0x80));                                                               
			myFflagN_s(0);
			io_writeByte(HL,reg);

			PC++;
			return(11);
		}

	case 0x23 :
		{
			HL++;

			PC++;
			return(6);
		}

	case 0x03 :
		{
			BC++;

			PC++;
			return(6);
		}

	case 0x13 :
		{
			DE++;

			PC++;
			return(6);
		}

	case 0x33 :
		{
			SP++;

			PC++;
			return(6);
		}

		/* komandi push */

	case 0xf5 :
		{
			push(AF);
			PC++;
			return(11);
		}

	case 0xc5 :
		{
			push(BC);
			PC++;
			return(11);
		}

	case 0xd5 :
		{
			push(DE);
			PC++;
			return(11);
		}

	case 0xe5 :
		{
			push(HL);
			PC++;
			return(11);
		}

		/*	komandi prostogo vichitania */

	case 0x97 :
		{
			val=A;	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x94 :
		{
			val=H;	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             

			myFflagPV_s( sub_overflow_tbl(idx >> 4) );                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x95 :
		{
			val=L;	


			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x90 :
		{
			val=B;	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x91 :
		{
			val=C;	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x92 :
		{
			val=D;	


			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x93 :
		{
			val=E;	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0xd6 :
		{
			val=io_readByte(PC+1);	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       

				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC+=2;
			return(7);
		}

	case 0x96 :
		{
			val=io_readByte(HL);	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(7);
		}

		/* komandi pop */

	case 0xf1 :
		{
			pop(&work16);
			A=work16/256;
			F=work16-A*256;


			PC++;
			return(10);
		}

	case 0xc1 :
		{
			pop(&work16);
			B=work16/256;
			C=work16-B*256;

			PC++;
			return(10);
		}

	case 0xd1 :
		{
			pop(&work16);
			D=work16/256;
			E=work16-D*256;

			PC++;
			return(10);
		}

	case 0xe1 :
		{
			pop(&work16);
			H=work16/256;
			L=work16-H*256;

			PC++;
			return(10);
		}
		/*
		/// POP END
		*/
		/* komandi obrazheniya k pzu (rst) */

	case 0xc7 :
		{
			push(PC+1);
			PC=0x0000;
			return(11);
		}

	case 0xcf :
		{
			push(PC+1);
			PC=0x0008;
			return(11);
		}

	case 0xd7 :
		{
			push(PC+1);
			PC=0x0010;
			return(11);
		}

	case 0xdf :
		{
			push(PC+1);
			PC=0x0018;
			return(11);
		}

	case 0xe7 :
		{
			push(PC+1);
			PC=0x0020;
			return(11);
		}

	case 0xef :
		{
			push(PC+1);
			PC=0x0028;
			return(11);
		}

	case 0xf7 :
		{
			push(PC+1);
			PC=0x0030;
			return(11);
		}

	case 0xff :
		{
			push(PC+1);
			PC=0x0038;
			return(11);
		}


		/* komandi rotatsii bitov */


	case 0x0f: /* rrca */
		{
			myFflagC_s( A & 1);
			A = (A >> 1) | (128 * myFflagC_r());
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}

	case 0x1f: /* rra */
		{
			work8 = myFflagC_r();
			myFflagC_s( A & 0x01);
			A = (A >> 1) | (work8 * 128);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}

	case 0x07 : /* rlca */
		{
			myFflagC_s( ((A & 0x80) != 0));
			A = (A << 1) | myFflagC_r();
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}

	case 0x17 : /* rla */
		{ 
			work8 = myFflagC_r();
			myFflagC_s( ((A & 0x80) != 0) );
			A = (A << 1) | work8;
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(4);
		}

		/* komandi vizova podprogramm */

	case 0xcd :
		{
			push(PC+3);
			io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
			return(17);
		}

	case 0xdc :
		{
			if (myFflagC_r())
			{
				push(PC+3);
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
				return(17);
			}
			PC+=3;
			return(11);
		}

	case 0xd4 :
		{
			if (!myFflagC_r())
			{
				push(PC+3);
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
				return(17);
			}
			PC+=3;
			return(11);
		}

	case 0xcc :

		{
			if (F&64)
			{
				push(PC+3);
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
				return(17);
			}
			PC+=3;
			return(11);
		}

	case 0xc4 :
		{
			if (!(F&64))
			{
				push(PC+3);
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
				return(17);
			}
			PC+=3;
			return(11);
		}

	case 0xfc :
		{
			if (F&128)
			{
				push(PC+3);
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
				return(17);
			}
			PC+=3;
			return(11);
		}

	case 0xf4 :
		{
			if (!(F&128))
			{
				push(PC+3);
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
				return(17);
			}
			PC+=3;
			return(11);
		}

	case 0xec :
		{
			if (F&4)
			{
				push(PC+3);
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
				return(17);
			}
			PC+=3;
			return(11);
		}

	case 0xe4 :
		{
			if (!(F&4))

			{
				push(PC+3);
				io_writeToRamAddrSpAddr((unsigned char *)&PC, PC+1);
				return(17);
			}
			PC+=3;
			return(11);
		}

		/* komandi vozvrata iz podprogramm */

	case 0xc9 :
		{
			pop(&PC);
			return(10);
		}

	case 0xd8 :
		{
			if (myFflagC_r())

			{
				pop(&PC);
				return(11);
			}
			PC++;
			return(5);
		}

	case 0xd0 :

		{
			if (!myFflagC_r())
			{
				pop(&PC);
				return(11);
			}
			PC++;
			return(5);
		}

	case 0xc8 :
		{
			if (F&64)
			{
				pop(&PC);
				return(11);
			}
			PC++;


			return(5);
		}

	case 0xc0 :
		{
			if (!(F&64))
			{
				pop(&PC);
				return(11);
			}
			PC++;
			return(5);
		}


	case 0xf8 :
		{

			if (F&128)
			{
				pop(&PC);
				return(11);
			}
			PC++;
			return(5);
		}

	case 0xf0 :
		{
			if (!(F&128))
			{
				pop(&PC);
				return(11);
			}
			PC++;
			return(5);
		}

	case 0xe8 :

		{
			if (F&4)
			{
				pop(&PC);
				return(11);
			}
			PC++;
			return(5);
		}

	case 0xe0 :
		{
			if (!(F&4))
			{
				pop(&PC);
				return(11);
			}
			PC++;
			return(5);
		}

	case 0xd3: /* out (n),a */
		{
			OutPort(io_readByte(PC+1),A,A);
			PC+=2;
			return(11);
		}

	case 0xdb: /* in a, (n) */
		{
			A=InPort(io_readByte(PC+1),A);
			PC+=2;
			return(11);
		}

		/* komandi slojeniya s uchetom perenosa */

	case 0x8f:
		{
			val=A;

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(4);
		}

	case 0x8c:
		{
			val=H;

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(4);
		}

	case 0x8d:
		{
			val=L;

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );


			PC++;
			return(4);
		}


	case 0x88:

		{
			val=B;

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x89:

		{
			val=C;

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;



			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x8a:
		{
			val=D;

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               


				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0x8b:
		{
			val=E;

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       

			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(4);
		}

	case 0xce:
		{
			val=io_readByte(PC+1);

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC+=2;
			return(7);
		}

	case 0x8e:
		{
			val=io_readByte(HL);

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(7);
		}


	case 0x00: /* nop */
		{
			PC++;
			return(4);
		}

	case 0x2f: /* cpl */
		{
			A^=0xff;

			myFflagH_s(1);
			myFflagN_s(1);

			PC++;
			return(4);
		}

	case 0x37: /* scf */
		{
			myFflagC_s(1);
			myFflagN_s(0); 
			myFflagH_s(0);

			PC++;
			return(4);
		}

	case 0x3f: /* ccf */
		{
			myFflagH_s(    myFflagC_r()); 
			myFflagN_s(0); 

			if (myFflagC_r())
				myFflagC_s(0);
			else
				myFflagC_s(1);

			PC++;
			return(4);

		}

	case 0xe3: /* ex (sp),hl */
		{
			pop(&XX);
			push(HL);
			HL=XX;

			PC++;
			return(19);
		}

	case 0x76: /* halt */
		{
			halted=on;

			PC++;

			return(4);
		}



	case 0x27: /* daa */
		{
			add = 0, carry = myFflagC_r();

			if( ( F&16 ) || ( (A & 0x0f)>9 ) ) add=6;
			if( carry || (A > 0x9f ) ) add|=0x60;
			if( A > 0x99 ) carry=1;

			if ( F&2 /* Flag N */ ) A-=add;
			else 
			{
				if( (A>0x90) && ( (A & 0x0f)>9) ) add|=0x60;
				A+=add;
			}

			if (carry==1)
				myFflagC_s(1);
			else
				myFflagC_s(0);

			ZeroA;

			ZnakA;
			ParityA;

			PC++;
			return(4);
		}

		/* S prefiksom */

	case 0xDD:
		{
			R++;
			PC++;
			return(DD());
		}

	case 0xFD:
		{
			R++;
			PC++;
			return(FD());
		}

	case 0xED:
		{
			R++;
			PC++;
			return(ED());
		}

	case 0xCB:
		{
			R++;
			PC++;
			return(CB());
		}
	}

	printf("\nZ80 : Unknown instruction %x at address %x.\n",io_readByte(PC),PC);
	ExitWithError(-1,"");

	return(0); /* eto chtob ne kvakalo */
}


void RLC (unsigned char * reg)
{                                                                                                    
	myFflagC_s((*reg & 0x80) != 0);                                                
	znak(*reg);                                                
	zero(*reg);
	parity(*reg);
	myFflagH_s(0);
	myFflagN_s(0);
}                                 

int CB (void)
{
	switch(io_readByte(PC))
	{
		/* komandi vklyuchenuia bitov */

	case 0xc7: 
		{
			A|=1;
			PC++;
			return(8);
		}

	case 0xc4: 
		{
			H|=1;
			PC++;
			return(8);
		}

	case 0xc5: 
		{
			L|=1;
			PC++;
			return(8);
		}

	case 0xc0: 
		{
			B|=1;
			PC++;
			return(8);
		}

	case 0xc1: 
		{
			C|=1;
			PC++;
			return(8);
		}

	case 0xc2: 
		{
			D|=1;
			PC++;
			return(8);
		}

	case 0xc3: 
		{
			E|=1;
			PC++;
			return(8);
		}

	case 0xc6: 
		{
			work8=io_readByte(HL);
			work8|=1;
			io_writeByte(HL,work8);
			PC++;
			return(15);
		}


	case 0xcf: 
		{
			A|=2;
			PC++;
			return(8);
		}

	case 0xcc: 
		{
			H|=2;
			PC++;
			return(8);
		}

	case 0xcd: 
		{
			L|=2;
			PC++;
			return(8);
		}

	case 0xc8: 

		{
			B|=2;
			PC++;
			return(8);
		}

	case 0xc9: 
		{
			C|=2;
			PC++;
			return(8);
		}

	case 0xca: 
		{
			D|=2;
			PC++;
			return(8);
		}

	case 0xcb: 
		{
			E|=2;
			PC++;
			return(8);
		}

	case 0xce: 
		{
			work8=io_readByte(HL);
			work8|=2;
			io_writeByte(HL,work8);

			PC++;
			return(15);
		}


	case 0xd7: 
		{
			A|=4;
			PC++;
			return(8);
		}

	case 0xd4: 
		{
			H|=4;
			PC++;
			return(8);
		}

	case 0xd5: 
		{
			L|=4;
			PC++;
			return(8);
		}

	case 0xd0: 
		{
			B|=4;
			PC++;
			return(8);
		}

	case 0xd1: 

		{
			C|=4;
			PC++;
			return(8);
		}

	case 0xd2: 
		{
			D|=4;
			PC++;
			return(8);
		}

	case 0xd3: 
		{
			E|=4;
			PC++;
			return(8);
		}

	case 0xd6: 
		{
			work8=io_readByte(HL);
			work8|=4;
			io_writeByte(HL,work8);

			PC++;
			return(15);
		}


	case 0xdf: 
		{
			A|=8;
			PC++;
			return(8);
		}

	case 0xdc: 
		{
			H|=8;
			PC++;
			return(8);
		}

	case 0xdd: 
		{


			L|=8;
			PC++;
			return(8);
		}

	case 0xd8: 
		{
			B|=8;
			PC++;
			return(8);
		}

	case 0xd9: 
		{
			C|=8;
			PC++;
			return(8);
		}

	case 0xda: 
		{
			D|=8;
			PC++;
			return(8);
		}

	case 0xdb: 
		{
			E|=8;
			PC++;
			return(8);
		}

	case 0xde: 
		{
			work8=io_readByte(HL);
			work8|=8;
			io_writeByte(HL,work8);	

			PC++;
			return(15);
		}


	case 0xe7: 
		{
			A|=16;
			PC++;
			return(8);
		}

	case 0xe4: 
		{
			H|=16;
			PC++;
			return(8);
		}

	case 0xe5: 
		{
			L|=16;
			PC++;
			return(8);
		}

	case 0xe0: 
		{
			B|=16;
			PC++;
			return(8);
		}

	case 0xe1: 
		{
			C|=16;
			PC++;
			return(8);
		}

	case 0xe2: 
		{
			D|=16;
			PC++;
			return(8);
		}

	case 0xe3: 
		{
			E|=16;
			PC++;
			return(8);
		}

	case 0xe6: 
		{
			work8=io_readByte(HL);
			work8|=16;
			io_writeByte(HL,work8);

			PC++;
			return(15);
		}



	case 0xef: 
		{
			A|=32;
			PC++;
			return(8);
		}

	case 0xec: 
		{
			H|=32;
			PC++;
			return(8);
		}

	case 0xed: 
		{
			L|=32;
			PC++;
			return(8);
		}

	case 0xe8: 
		{
			B|=32;
			PC++;
			return(8);
		}

	case 0xe9: 
		{
			C|=32;
			PC++;
			return(8);
		}

	case 0xea: 
		{
			D|=32;
			PC++;
			return(8);
		}

	case 0xeb: 
		{
			E|=32;
			PC++;
			return(8);
		}

	case 0xee: 
		{
			work8=io_readByte(HL);
			work8|=32;
			io_writeByte(HL,work8);

			PC++;
			return(15);
		}


	case 0xf7: 
		{
			A|=64;
			PC++;
			return(8);
		}

	case 0xf4: 
		{
			H|=64;
			PC++;
			return(8);
		}

	case 0xf5: 
		{
			L|=64;
			PC++;
			return(8);
		}

	case 0xf0: 
		{
			B|=64;
			PC++;
			return(8);
		}

	case 0xf1: 

		{
			C|=64;
			PC++;
			return(8);
		}

	case 0xf2: 
		{
			D|=64;
			PC++;
			return(8);
		}

	case 0xf3: 
		{
			E|=64;
			PC++;
			return(8);
		}

	case 0xf6: 
		{

			work8=io_readByte(HL);
			work8|=64;
			io_writeByte(HL,work8);	

			PC++;
			return(15);
		}


	case 0xff: 
		{

			A|=128;
			PC++;
			return(8);
		}

	case 0xfc: 
		{
			H|=128;
			PC++;
			return(8);
		}

	case 0xfd: 
		{
			L|=128;
			PC++;
			return(8);
		}

	case 0xf8: 
		{
			B|=128;
			PC++;
			return(8);
		}

	case 0xf9: 
		{
			C|=128;
			PC++;
			return(8);
		}

	case 0xfa: 
		{
			D|=128;
			PC++;
			return(8);
		}

	case 0xfb: 
		{
			E|=128;
			PC++;
			return(8);
		}

	case 0xfe: 
		{
			work8=io_readByte(HL);
			work8|=128;
			io_writeByte(HL,work8);

			PC++;
			return(15);
		}

		/* viklucheniye bitov */

	case 0x87: 
		{
			A&=0xfe;
			PC++;
			return(8);
		}

	case 0x84: 
		{
			H&=0xfe;
			PC++;
			return(8);
		}

	case 0x85: 
		{
			L&=0xfe;
			PC++;
			return(8);
		}

	case 0x80: 
		{
			B&=0xfe;
			PC++;
			return(8);
		}

	case 0x81: 
		{
			C&=0xfe;
			PC++;
			return(8);
		}

	case 0x82: 
		{
			D&=0xfe;
			PC++;
			return(8);
		}

	case 0x83: 
		{
			E&=0xfe;
			PC++;
			return(8);
		}

	case 0x86: 
		{
			work8=io_readByte(HL);
			work8&=0xfe;
			io_writeByte(HL,work8);

			PC++;
			return(15);
		}


	case 0x8f: 
		{
			A&=0xfd;
			PC++;
			return(8);
		}

	case 0x8c: 
		{
			H&=0xfd;
			PC++;
			return(8);
		}

	case 0x8d: 
		{
			L&=0xfd;
			PC++;
			return(8);
		}

	case 0x88: 
		{
			B&=0xfd;
			PC++;
			return(8);
		}

	case 0x89: 
		{
			C&=0xfd;
			PC++;
			return(8);
		}

	case 0x8a: 
		{
			D&=0xfd;
			PC++;


			return(8);
		}

	case 0x8b: 
		{
			E&=0xfd;
			PC++;
			return(8);
		}

	case 0x8e: 
		{
			work8=io_readByte(HL);
			work8&=0xfd;
			io_writeByte(HL,work8);

			PC++;
			return(15);
		}


	case 0x97: 
		{
			A&=0xfb;
			PC++;
			return(8);
		}


	case 0x94: 
		{
			H&=0xfb;
			PC++;
			return(8);

		}

	case 0x95: 
		{
			L&=0xfb;
			PC++;
			return(8);
		}

	case 0x90: 
		{
			B&=0xfb;
			PC++;

			return(8);
		}


	case 0x91: 
		{
			C&=0xfb;
			PC++;
			return(8);


		}

	case 0x92: 
		{


			D&=0xfb;
			PC++;
			return(8);
		}

	case 0x93: 
		{
			E&=0xfb;
			PC++;
			return(8);
		}

	case 0x96: 
		{
			work8=io_readByte(HL);
			work8&=0xfb;
			io_writeByte(HL,work8);

			PC++;
			return(15);
		}


	case 0x9f: 
		{
			A&=0xf7;
			PC++;


			return(8);
		}


	case 0x9c: 
		{
			H&=0xf7;
			PC++;
			return(8);
		}

	case 0x9d: 
		{

			L&=0xf7;
			PC++;
			return(8);
		}

	case 0x98: 
		{
			B&=0xf7;
			PC++;
			return(8);
		}

	case 0x99: 
		{
			C&=0xf7;
			PC++;
			return(8);
		}

	case 0x9a: 
		{
			D&=0xf7;
			PC++;
			return(8);
		}

	case 0x9b: 
		{
			E&=0xf7;
			PC++;
			return(8);
		}

	case 0x9e: 
		{
			work8=io_readByte(HL);
			work8&=0xf7;
			io_writeByte(HL,work8);

			PC++;
			return(15);
		}


	case 0xa7: 
		{
			A&=0xef;
			PC++;
			return(8);
		}

	case 0xa4: 
		{
			H&=0xef;
			PC++;
			return(8);
		}

	case 0xa5: 
		{
			L&=0xef;
			PC++;
			return(8);
		}

	case 0xa0: 
		{
			B&=0xef;
			PC++;
			return(8);
		}

	case 0xa1: 
		{
			C&=0xef;
			PC++;
			return(8);
		}



	case 0xa2: 
		{
			D&=0xef;
			PC++;
			return(8);
		}

	case 0xa3: 
		{
			E&=0xef;
			PC++;
			return(8);
		}

	case 0xa6: 
		{

			work8=io_readByte(HL);
			work8&=0xef;

			io_writeByte(HL,work8);

			PC++;
			return(15);
		}

	case 0xaf: 
		{
			A&=0xdf;
			PC++;
			return(8);
		}


	case 0xac: 

		{
			H&=0xdf;
			PC++;
			return(8);
		}

	case 0xad: 
		{
			L&=0xdf;
			PC++;
			return(8);
		}

	case 0xa8: 
		{
			B&=0xdf;
			PC++;

			return(8);
		}

	case 0xa9: 
		{
			C&=0xdf;
			PC++;
			return(8);
		}

	case 0xaa: 
		{
			D&=0xdf;
			PC++;
			return(8);
		}

	case 0xab: 
		{
			E&=0xdf;
			PC++;
			return(8);
		}

	case 0xae: 
		{
			work8=io_readByte(HL);
			work8&=0xdf;
			io_writeByte(HL,work8);

			PC++;
			return(15);
		}


	case 0xb7: 
		{
			A&=0xbf;
			PC++;
			return(8);
		}


	case 0xb4: 
		{
			H&=0xbf;
			PC++;
			return(8);
		}

	case 0xb5: 


		{
			L&=0xbf;
			PC++;
			return(8);
		}

	case 0xb0: 
		{
			B&=0xbf;
			PC++;
			return(8);
		}

	case 0xb1: 
		{
			C&=0xbf;

			PC++;
			return(8);
		}

	case 0xb2: 
		{

			D&=0xbf;
			PC++;
			return(8);
		}

	case 0xb3: 
		{
			E&=0xbf;
			PC++;
			return(8);
		}

	case 0xb6: 
		{

			work8=io_readByte(HL);
			work8&=0xbf;
			io_writeByte(HL,work8);

			PC++;
			return(15);
		}

	case 0xbf: 
		{
			A&=0x7f;
			PC++;
			return(8);
		}

	case 0xbc: 
		{
			H&=0x7f;
			PC++;
			return(8);
		}

	case 0xbd: 
		{
			L&=0x7f;
			PC++;
			return(8);
		}

	case 0xb8: 
		{
			B&=0x7f;
			PC++;
			return(8);
		}

	case 0xb9: 
		{
			C&=0x7f;
			PC++;
			return(8);
		}

	case 0xba: 
		{
			D&=0x7f;
			PC++;
			return(8);
		}

	case 0xbb: 
		{
			E&=0x7f;
			PC++;
			return(8);
		}

	case 0xbe: 
		{
			work8=io_readByte(HL);
			work8&=0x7f;
			io_writeByte(HL,work8);


			PC++;
			return(15);
		}

		/* proverka bitov */

	case 0x47: 
		{
			bit(A,0);
			PC++;
			return(8);
		}

	case 0x44: 
		{
			bit(H,0);
			PC++;
			return(8);
		}

	case 0x45: 
		{
			bit(L,0);
			PC++;
			return(8);
		}

	case 0x40: 
		{
			bit(B,0);
			PC++;
			return(8);
		}

	case 0x41: 
		{
			bit(C,0);
			PC++;
			return(8);
		}

	case 0x42: 
		{

			bit(D,0);
			PC++;
			return(8);
		}

	case 0x43: 
		{
			bit(E,0);
			PC++;
			return(8);
		}

	case 0x46: 
		{
			bit(io_readByte(HL),0);
			PC++;
			return(15);
		}

	case 0x4f: 


		{
			bit(A,1);
			PC++;
			return(8);
		}

	case 0x4c: 
		{
			bit(H,1);
			PC++;
			return(8);
		}

	case 0x4d: 
		{
			bit(L,1);
			PC++;
			return(8);
		}


	case 0x48: 
		{
			bit(B,1);
			PC++;
			return(8);
		}

	case 0x49: 
		{
			bit(C,1);
			PC++;
			return(8);
		}

	case 0x4a: 
		{
			bit(D,1);
			PC++;
			return(8);
		}

	case 0x4b: 
		{
			bit(E,1);
			PC++;
			return(8);
		}

	case 0x4e: 
		{
			bit(io_readByte(HL),1);
			PC++;
			return(15);
		}


	case 0x57: 
		{
			bit(A,2);
			PC++;
			return(8);
		}

	case 0x54: 
		{
			bit(H,2);
			PC++;
			return(8);
		}

	case 0x55: 
		{
			bit(L,2);
			PC++;
			return(8);
		}

	case 0x50: 
		{
			bit(B,2);
			PC++;
			return(8);
		}

	case 0x51: 
		{
			bit(C,2);
			PC++;
			return(8);
		}

	case 0x52: 
		{
			bit(D,2);
			PC++;
			return(8);

		}

	case 0x53: 
		{
			bit(E,2);
			PC++;
			return(8);
		}

	case 0x56: 
		{
			bit(io_readByte(HL),2);
			PC++;
			return(15);
		}


	case 0x5f: 
		{
			bit(A,3);
			PC++;
			return(8);
		}

	case 0x5c: 
		{
			bit(H,3);
			PC++;
			return(8);
		}

	case 0x5d: 
		{
			bit(L,3);
			PC++;
			return(8);
		}

	case 0x58: 
		{
			bit(B,3);
			PC++;
			return(8);
		}

	case 0x59: 
		{
			bit(C,3);
			PC++;
			return(8);
		}

	case 0x5a: 
		{
			bit(D,3);
			PC++;
			return(8);
		}

	case 0x5b: 
		{
			bit(E,3);
			PC++;
			return(8);
		}

	case 0x5e: 
		{
			bit(io_readByte(HL),3);
			PC++;
			return(15);
		}


	case 0x67: 
		{
			bit(A,4);
			PC++;
			return(8);
		}

	case 0x64: 
		{
			bit(H,4);
			PC++;
			return(8);
		}

	case 0x65: 
		{
			bit(L,4);
			PC++;
			return(8);
		}

	case 0x60: 
		{
			bit(B,4);
			PC++;
			return(8);
		}

	case 0x61: 
		{
			bit(C,4);
			PC++;
			return(8);
		}

	case 0x62: 
		{
			bit(D,4);
			PC++;
			return(8);
		}

	case 0x63: 
		{
			bit(E,4);
			PC++;
			return(8);
		}

	case 0x66: 
		{
			bit(io_readByte(HL),4);
			PC++;
			return(15);
		}


	case 0x6f: 
		{
			bit(A,5);
			PC++;
			return(8);
		}

	case 0x6c: 
		{
			bit(H,5);
			PC++;
			return(8);
		}

	case 0x6d: 
		{
			bit(L,5);
			PC++;
			return(8);
		}

	case 0x68: 
		{
			bit(B,5);
			PC++;
			return(8);
		}

	case 0x69: 
		{
			bit(C,5);
			PC++;
			return(8);
		}

	case 0x6a: 
		{
			bit(D,5);
			PC++;
			return(8);
		}

	case 0x6b: 
		{
			bit(E,5);
			PC++;
			return(8);
		}

	case 0x6e: 
		{
			bit(io_readByte(HL),5);
			PC++;
			return(15);
		}


	case 0x77: 
		{
			bit(A,6);
			PC++;
			return(8);
		}

	case 0x74: 
		{
			bit(H,6);
			PC++;
			return(8);
		}

	case 0x75: 
		{

			bit(L,6);
			PC++;
			return(8);
		}

	case 0x70: 
		{
			bit(B,6);
			PC++;
			return(8);
		}


	case 0x71: 
		{
			bit(C,6);
			PC++;
			return(8);
		}

	case 0x72: 
		{
			bit(D,6);
			PC++;
			return(8);
		}

	case 0x73: 
		{
			bit(E,6);
			PC++;
			return(8);
		}

	case 0x76: 
		{
			bit(io_readByte(HL),6);
			PC++;
			return(15);
		}



	case 0x7f: 
		{
			bit(A,7);
			PC++;
			return(8);
		}

	case 0x7c: 
		{
			bit(H,7);
			PC++;
			return(8);
		}

	case 0x7d: 
		{
			bit(L,7);
			PC++;
			return(8);
		}

	case 0x78: 
		{
			bit(B,7);
			PC++;
			return(8);
		}

	case 0x79: 
		{
			bit(C,7);
			PC++;
			return(8);
		}

	case 0x7a: 
		{
			bit(D,7);
			PC++;
			return(8);
		}

	case 0x7b: 
		{
			bit(E,7);
			PC++;
			return(8);
		}

	case 0x7e: 
		{
			bit(io_readByte(HL),7);
			PC++;
			return(15);
		}

		/* komandi sdviga i rottatsii bitov */

		/* komandi srl */
	case 0x3f:
		{
			myFflagC_s( A & 0x01);                                                                  
			A >>= 1;                                                                                   
			znak(A);                                                
			zero(A);
			parity(A);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x3c:
		{
			myFflagC_s( H & 0x01);                                                                  
			H >>= 1;                                                                                   
			znak(H);                                                
			zero(H);
			parity(H);

			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x3d:
		{
			myFflagC_s( L & 0x01);                                                                  
			L>>= 1;                                                                                   
			znak(L);                                                
			zero(L);
			parity(L);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x38:
		{
			myFflagC_s( B & 0x01);                                                                  
			B>>= 1;                                                                                   
			znak(B);                                                
			zero(B);
			parity(B);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x39:
		{
			myFflagC_s( C & 0x01);                                                                  
			C>>= 1;                                                                                   

			znak(C);                                                
			zero(C);
			parity(C);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x3a:
		{
			myFflagC_s( D & 0x01);                                                                  
			D>>= 1;                                                                                   
			znak(D);                                                
			zero(D);
			parity(D);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x3b:
		{
			myFflagC_s( E & 0x01);                                                                  
			E>>= 1;                                                                                   
			znak(E);                                                
			zero(E);
			parity(E);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}


	case 0x3e:
		{
			myFflagC_s( io_readByte(HL) & 0x01);

			work8=io_readByte(HL);
			work8>>=1;
			io_writeByte(HL,work8);

			znak(io_readByte(HL));                                                
			zero(io_readByte(HL));
			parity(io_readByte(HL));
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(15);
		}

		/* komandi rlc */
	case 0x07:
		{
			myFflagC_s( ((A & 0x80) != 0));                                                 
			A= (A << 1) | myFflagC_r();
			znak(A);                                                
			zero(A);
			parity(A);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x04:
		{
			myFflagC_s( ((H & 0x80) != 0));                                                 
			H= (H << 1) | myFflagC_r();
			znak(H);                                                
			zero(H);

			parity(H);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x05:
		{
			myFflagC_s( ((L & 0x80) != 0));                                                 

			L= (L << 1) | myFflagC_r();
			znak(L);                                                
			zero(L);
			parity(L);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x00:
		{
			myFflagC_s( ((B & 0x80) != 0));                                                
			B= (B << 1) | myFflagC_r();

			znak(B);                                                
			zero(B);
			parity(B);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}



	case 0x01:
		{
			myFflagC_s( ((C & 0x80) != 0));                                                 
			C= (C << 1) | myFflagC_r();
			znak(C);                                                
			zero(C);
			parity(C);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x02:
		{
			myFflagC_s( ((D & 0x80) != 0));                                                 
			D= (D << 1) | myFflagC_r();

			znak(D);                                                
			zero(D);
			parity(D);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x03:
		{
			myFflagC_s( ((E & 0x80) != 0));                                                 
			E= (E << 1) | myFflagC_r();
			znak(E);                                                
			zero(E);
			parity(E);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x06:
		{
			myFflagC_s( ((io_readByte(HL) & 0x80) != 0));                                                 
			io_writeByte(HL, ((io_readByte(HL) << 1) | myFflagC_r()));
			znak(io_readByte(HL));                                                
			zero(io_readByte(HL));
			parity(io_readByte(HL));
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(15);
		}

		/* komandi rl */

	case 0x17:
		{
			work8 = ((A & 0x80) != 0);                                                
			A= (A << 1) | myFflagC_r();                                                  
			myFflagC_s( work8);
			znak(A);                                                
			zero(A);
			parity(A);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x14:
		{
			work8 = ((H & 0x80) != 0);                                                
			H= (H << 1) | myFflagC_r();                                                  
			myFflagC_s( work8 );
			znak(H);                                                
			zero(H);
			parity(H);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x15:
		{
			work8 = ((L & 0x80) != 0);                                                
			L= (L << 1) | myFflagC_r();                                                  
			myFflagC_s( work8 );
			znak(L);                                                
			zero(L);
			parity(L);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x10:
		{
			work8 = ((B & 0x80) != 0);                                                
			B= (B << 1) | myFflagC_r();                                                  
			myFflagC_s( work8 );
			znak(B);                                                
			zero(B);
			parity(B);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x11:

		{
			work8 = ((C & 0x80) != 0);                                                
			C= (C << 1) | myFflagC_r();                                                  
			myFflagC_s( work8 );
			znak(C);                                                
			zero(C);
			parity(C);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x12:
		{
			work8 = ((D & 0x80) != 0);                                                
			D= (D << 1) | myFflagC_r();                                                  
			myFflagC_s(work8 );
			znak(D);                                                
			zero(D);
			parity(D);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x13:
		{
			work8 = ((E & 0x80) != 0);                                                
			E= (E << 1) | myFflagC_r();                                                  
			myFflagC_s( work8 );
			znak(E);                                                
			zero(E);
			parity(E);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x16:
		{
			work8 = ((io_readByte(HL) & 0x80) != 0);                                                
			io_writeByte(HL, ((io_readByte(HL) << 1) | myFflagC_r()));                                                  
			myFflagC_s( work8 );
			znak(io_readByte(HL));                                                
			zero(io_readByte(HL));
			parity(io_readByte(HL));
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(15);
		}

		/* komandi rr */

	case 0x1f:
		{
			work8 = A & 0x01;                                                                 
			A= (A >> 1) | (myFflagC_r() * 128);                                   
			myFflagC_s( work8 );

			znak(A);                                                
			zero(A);
			parity(A);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x1c:
		{
			work8 = H & 0x01;                                                                 
			H= (H >> 1) | (myFflagC_r() * 128);                                   
			myFflagC_s( work8 );

			znak(H);                                                
			zero(H);
			parity(H);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x1d:
		{
			work8 = L & 0x01;                                                                 
			L= (L >> 1) | (myFflagC_r() * 128);                                   
			myFflagC_s( work8 );

			znak(L);                                                
			zero(L);
			parity(L);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x18:
		{
			work8 = B & 0x01;                                                                 
			B= (B >> 1) | (myFflagC_r() * 128);                                   
			myFflagC_s( work8 );

			znak(B);                                                
			zero(B);
			parity(B);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x19:
		{
			work8 = C & 0x01;                                                                 
			C= (C >> 1) | (myFflagC_r() * 128);                                   
			myFflagC_s( work8 );

			znak(C);                                                
			zero(C);
			parity(C);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x1a:
		{
			work8 = D & 0x01;                                                                 
			D= (D >> 1) | (myFflagC_r() * 128);                                   
			myFflagC_s( work8 );

			znak(D);                                                
			zero(D);
			parity(D);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x1b:
		{
			work8 = E & 0x01;                                                                 
			E= (E >> 1) | (myFflagC_r() * 128);                                   
			myFflagC_s( work8 );

			znak(E);                                                
			zero(E);
			parity(E);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x1e:
		{
			work8 = io_readByte(HL) & 0x01;                                                                 
			io_writeByte(HL, ((io_readByte(HL) >> 1) | (myFflagC_r() * 128)));                                   
			myFflagC_s( work8 );

			znak(io_readByte(HL));                                                
			zero(io_readByte(HL));
			parity(io_readByte(HL));
			myFflagH_s(0);
			myFflagN_s(0);


			PC++;

			return(15);
		}

		/* komandi sla */

	case 0x27:
		{  
			myFflagC_s( ((A & 0x80) != 0) );                                                 
			A<<= 1;                                                                                    


			znak(A);                                                
			zero(A);
			parity(A);
			myFflagH_s(0);
			myFflagN_s(0);


			PC++;
			return(8);
		}

	case 0x24:
		{  
			myFflagC_s( ((H & 0x80) != 0) );                                                 
			H<<= 1;                                                                               

			znak(H);                                                
			zero(H);

			parity(H);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x25:
		{  
			myFflagC_s( ((L & 0x80) != 0) );                                                 
			L<<= 1;                                                                                    

			znak(L);                                                
			zero(L);
			parity(L);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;

			return(8);
		}

	case 0x20:
		{  
			myFflagC_s( ((B & 0x80) != 0) );                                                 
			B<<= 1;                                                                                    

			znak(B);                                                
			zero(B);
			parity(B);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x21:
		{  
			myFflagC_s( ((C & 0x80) != 0));                                                 

			C<<= 1;                                                                                    


			znak(C);                                                
			zero(C);
			parity(C);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x22:
		{  
			myFflagC_s( ((D & 0x80) != 0));                                                 
			D<<= 1;                                                                                    

			znak(D);                                                
			zero(D);
			parity(D);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x23:
		{  
			myFflagC_s( ((E & 0x80) != 0) );                                                 
			E <<= 1;                                                                                    

			znak(E);                                                
			zero(E);
			parity(E);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x26:

		{  
			myFflagC_s( ((io_readByte(HL) & 0x80) != 0));                                                 


			work8=io_readByte(HL);
			work8<<=1;
			io_writeByte(HL,work8);

			znak(io_readByte(HL));                                                
			zero(io_readByte(HL));
			parity(io_readByte(HL));

			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(15);
		}


		/* komandi rrc */

	case 0x0f:
		{
			myFflagC_s( A & 0x01 );                                                                  
			A= (A >> 1) | (myFflagC_r() * 128);                                   

			znak(A);                                                
			zero(A);
			parity(A);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);	
		}

	case 0x0c:
		{
			myFflagC_s( H & 0x01 );                                                                  
			H= (H >> 1) | (myFflagC_r() * 128);                                   

			znak(H);                                                
			zero(H);
			parity(H);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);	
		}

	case 0x0d:
		{
			myFflagC_s( L & 0x01);                                                                  
			L= (L >> 1) | (myFflagC_r() * 128);                                   

			znak(L);                                                
			zero(L);
			parity(L);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);	
		}

	case 0x08:
		{
			myFflagC_s( B & 0x01);                                                                  
			B= (B >> 1) | (myFflagC_r() * 128);                                   

			znak(B);                                                
			zero(B);
			parity(B);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);	
		}

	case 0x09:

		{
			myFflagC_s( C & 0x01);                                                                  
			C= (C >> 1) | (myFflagC_r() * 128);                                   

			znak(C);                                                
			zero(C);
			parity(C);
			myFflagH_s(0);
			myFflagN_s(0);


			PC++;
			return(8);	
		}

	case 0x0a:
		{
			myFflagC_s( D & 0x01 );                                                                  
			D= (D >> 1) | (myFflagC_r() * 128);                                   

			znak(D);                                                
			zero(D);
			parity(D);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);	
		}

	case 0x0b:
		{
			myFflagC_s( E & 0x01 );                                                                  
			E= (E >> 1) | (myFflagC_r() * 128);                                   

			znak(E);                                                
			zero(E);
			parity(E);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);	
		}

	case 0x0e:
		{
			myFflagC_s( io_readByte(HL) & 0x01);                                                                  
			io_writeByte(HL, ((io_readByte(HL) >> 1) | (myFflagC_r() * 128)));                                   

			znak(io_readByte(HL));                                                
			zero(io_readByte(HL));
			parity(io_readByte(HL));
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(15);	
		}

		/* komandi sra */

	case 0x2f:
		{
			myFflagC_s( A & 0x01);                                                                  
			work8 = A & 0x80;                                                                 
			A= (A >> 1) | work8;                                                 

			znak(A);                                                
			zero(A);
			parity(A);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x2c:
		{
			myFflagC_s( H & 0x01);                                                                  
			work8 = H & 0x80;                                                                 
			H= (H >> 1) | work8;                                                 

			znak(H);                                                
			zero(H);
			parity(H);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x2d:
		{
			myFflagC_s( L & 0x01 );                                                                  
			work8 = L & 0x80;                                                                 
			L= (L >> 1) | work8;                                                 

			znak(L);                                                
			zero(L);
			parity(L);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x28:
		{
			myFflagC_s( B & 0x01);                                                                  
			work8 = B & 0x80;                                                                 
			B= (B >> 1) | work8;                                                 

			znak(B);                                                
			zero(B);
			parity(B);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x29:
		{
			myFflagC_s( C & 0x01 );                                                                  
			work8 = C & 0x80;                                                                 
			C= (C >> 1) | work8;                                                 

			znak(C);                                                
			zero(C);
			parity(C);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x2a:
		{
			myFflagC_s( D & 0x01 );                                                                  
			work8 = D & 0x80;                                                                 
			D= (D >> 1) | work8;                                                 

			znak(D);                                                
			zero(D);
			parity(D);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x2b:
		{
			myFflagC_s( E & 0x01 );                                                                  
			work8 = E & 0x80;                                                                 
			E= (E >> 1) | work8;                                                 

			znak(E);                                                
			zero(E);
			parity(E);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x2e:
		{
			myFflagC_s( io_readByte(HL) & 0x01 );                                                                  
			work8 = io_readByte(HL) & 0x80;                                                                 
			io_writeByte(HL, ((io_readByte(HL) >> 1) | work8));                                                 

			znak(io_readByte(HL));                                                
			zero(io_readByte(HL));
			parity(io_readByte(HL));
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

		/* komandi sli */

	case 0x30:
		{
			myFflagC_s( ((B & 0x80) != 0));
			B= (B << 1) | 0x01;

			znak(B);
			zero(B);
			parity(B);

			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x31:
		{
			myFflagC_s( ((C & 0x80) != 0));
			C= (C << 1) | 0x01;

			znak(C);
			zero(C);
			parity(C);

			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x32:
		{
			myFflagC_s( ((D & 0x80) != 0));
			D= (D << 1) | 0x01;

			znak(D);
			zero(D);
			parity(D);

			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}

	case 0x33:
		{
			myFflagC_s( ((E & 0x80) != 0));
			E= (E << 1) | 0x01;

			znak(E);
			zero(E);
			parity(E);

			myFflagH_s(0);
			myFflagN_s(0);



			PC++;
			return(8);
		}	
	case 0x34:
		{
			myFflagC_s( ((H & 0x80) != 0));
			H= (H << 1) | 0x01;

			znak(H);
			zero(H);
			parity(H);

			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	case 0x35:
		{

			myFflagC_s( ((L & 0x80) != 0));
			L= (L << 1) | 0x01;

			znak(L);
			zero(L);
			parity(L);

			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	case 0x36:
		{
			work8 = io_readByte(HL);

			myFflagC_s( ((work8 & 0x80) != 0));
			work8= (work8 << 1) | 0x01;


			znak(work8);
			zero(work8);
			parity(work8);

			myFflagH_s(0);
			myFflagN_s(0);

			io_writeByte(HL, work8);

			PC++;
			return(15);
		}	

	case 0x37:
		{
			myFflagC_s( ((A & 0x80) != 0));
			A= (A << 1) | 0x01;

			znak(A);
			zero(A);
			parity(A);

			myFflagH_s(0);
			myFflagN_s(0);	

			PC++;
			return(8);
		}
	}

	printf("\nZ80 : Unknown instruction cb%x at address %x.\n",io_readByte(PC),PC-1);
	ExitWithError(-1,"");

	return(0); /* eto chtob ne kvakalo */
}

int FD (void)
{
	switch(io_readByte(PC))
	{
	case 0x21: /* ld iy, nn */
		{
			io_writeToRamAddrSpAddr((unsigned char *)&IY, PC+1);
			PC+=3;
			return(14);
		}

	case 0xf9: /* ld sp, iy */
		{
			SP=IY;
			PC++;
			return(10);
		}

	case 0x2a: /* ld iy, (nn) */
		{
			io_writeToRamAddrSpAddr((unsigned char *)&IY, ex(io_readByte(PC+2), io_readByte(PC+1)));

			PC+=3;
			return(20);
		}

	case 0x22: /* ld (nn), iy */
		{
			io_writeToSpAddrVal(ex(io_readByte(PC+2), io_readByte(PC+1)), IY);

			PC+=3;
			return(20);
		}

		/* zagruzka registrov iz pamyati indexnoy adresatsiei */

	case 0x7e: 
		{

			A=io_readByte(IY+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

	case 0x66: 

		{
			H=io_readByte(IY+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

	case 0x6e: 
		{
			L=io_readByte(IY+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

	case 0x46: 
		{
			B=io_readByte(IY+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

	case 0x4e: 
		{
			C=io_readByte(IY+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

	case 0x56: 
		{
			D=io_readByte(IY+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

	case 0x5e: 
		{
			E=io_readByte(IY+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

		/* zapis' v pamyat' indexnoy adresatsiei */

	case 0x77: 
		{
			io_writeByte(IY+(signed char)io_readByte(PC+1),A);
			PC+=2;
			return(19);
		}


	case 0x74: 
		{
			io_writeByte(IY+(signed char)io_readByte(PC+1),H);
			PC+=2;
			return(19);
		}

	case 0x75: 
		{
			io_writeByte(IY+(signed char)io_readByte(PC+1),L);
			PC+=2;
			return(19);
		}

	case 0x70: 
		{
			io_writeByte(IY+(signed char)io_readByte(PC+1),B);
			PC+=2;
			return(19);
		}

	case 0x71: 
		{
			io_writeByte(IY+(signed char)io_readByte(PC+1),C);
			PC+=2;
			return(19);
		}

	case 0x72: 
		{
			io_writeByte(IY+(signed char)io_readByte(PC+1),D);
			PC+=2;
			return(19);
		}

	case 0x73: 
		{
			io_writeByte(IY+(signed char)io_readByte(PC+1),E);
			PC+=2;
			return(19);
		}

	case 0x36: 
		{
			io_writeByte(IY+(signed char)io_readByte(PC+1),io_readByte(PC+2));
			PC+=3;
			return(19);
		}

	case 0xa6: /* and (iy+s) */
		{
			A=A&(io_readByte(IY+(signed char)io_readByte(PC+1)));

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC+=2;
			return(19);
		}	

	case 0xb6: /* or (iy+s) */
		{
			A=A|(io_readByte(IY+(signed char)io_readByte(PC+1)));

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC+=2;
			return(19);
		}	

	case 0xae: /* xor (iy+s) */
		{
			A=A^(io_readByte(IY+(signed char)io_readByte(PC+1)));

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC+=2;
			return(19);
		}	

	case 0xe9: /* jp (iy) */
		{
			PC=IY;
			return(8);
		}

	case 0x35: /* dec (iy+s) */
		{
			work8=io_readByte(IY+(signed char)io_readByte(PC+1));
			work8--;
			io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

			znak(io_readByte(IY+(signed char)io_readByte(PC+1)));
			zero(io_readByte(IY+(signed char)io_readByte(PC+1)));
			myFflagPV_s((io_readByte(IY+(signed char)io_readByte(PC+1))==0x7f));
			myFflagN_s(1);
			myFflagH_s(((io_readByte(IY+(signed char)io_readByte(PC+1))&0x0f)==0x0f));

			PC+=2;
			return(23);
		}

	case 0x2b: /* dec iy */
		{
			IY--;
			PC++;
			return(10);
		}


	case 0xbe: /* cp (iy+s) */
		{	
			val=io_readByte(IY+(signed char)io_readByte(PC+1));

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                

			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC+=2;
			return(19);
		}

	case 0x9e: /* sbc a, (iy+s) */
		{
			val=io_readByte(IY+(signed char)io_readByte(PC+1));

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC+=2;
			return(19);
		}

	case 0x86: /* add a, (iy+s) */
		{
			val=io_readByte(IY+(signed char)io_readByte(PC+1));

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC+=2;
			return(19);
		}

		/* komandi prostogo slojeniya */

	case 0x29:
		{
			reg=IY;
			XX=IY;

			work32 = XX + (reg);                                            
			idx = ((XX & 0x0800) >> 9) |                                    
				(((reg) & 0x0800) >> 10) |                            
				((work32 & 0x0800) >> 11);                            
			XX = work32 & 0xffff;                                           
			myFflagH_s(hcarry_tbl(idx));                                     
			myFflagN_s(0);                                                    
			myFflagC_s(((work32 & 0x10000) != 0));  
			IY=XX;

			PC++;
			return(15);
		}

	case 0x09:
		{
			reg=BC;
			XX=IY;

			work32 = XX + (reg);                                            
			idx = ((XX & 0x0800) >> 9) |                                    
				(((reg) & 0x0800) >> 10) |                            
				((work32 & 0x0800) >> 11);                            
			XX = work32 & 0xffff;                                           
			myFflagH_s(   hcarry_tbl(idx));                                     
			myFflagN_s(0);                                                    
			myFflagC_s( ((work32 & 0x10000) != 0));  
			IY=XX;

			PC++;
			return(15);
		}

	case 0x19:
		{
			reg=DE;
			XX=IY;

			work32 = XX + (reg);                                            
			idx = ((XX & 0x0800) >> 9) |                                    
				(((reg) & 0x0800) >> 10) |                            
				((work32 & 0x0800) >> 11);                            
			XX = work32 & 0xffff;                                           
			myFflagH_s(   hcarry_tbl(idx));                                     
			myFflagN_s(0);                                                    
			myFflagC_s( ((work32 & 0x10000) != 0));  
			IY=XX;

			PC++;
			return(15);
		}

	case 0x39:
		{
			reg=SP;
			XX=IY;

			work32 = XX + (reg);                                            
			idx = ((XX & 0x0800) >> 9) |                                    
				(((reg) & 0x0800) >> 10) |                            
				((work32 & 0x0800) >> 11);                            
			XX = work32 & 0xffff;                                           
			myFflagH_s(   hcarry_tbl(idx));                                     
			myFflagN_s(0);                                                    
			myFflagC_s( ((work32 & 0x10000) != 0));  
			IY=XX;

			PC++;
			return(15);
		}

	case 0x34 : /* inc (iy+s) */
		{
			reg=io_readByte(IY+(signed char)io_readByte(PC+1));

			reg++;                                                                                                
			znak(reg);                                                 
			zero(reg);                                                                  
			myFflagH_s(   (((reg) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((reg) == 0x80));                                                               
			myFflagN_s(0);
			io_writeByte(IY+(signed char)io_readByte(PC+1), reg);

			PC+=2;
			return(23);
		}

	case 0x23 : /* inc iy */
		{
			IY++;

			PC++;
			return(10);
		}

	case 0xcb :  
		{
			switch(io_readByte(PC+2))
			{
				/* vklyuchenie bitov */
			case 0xc6: 

				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8|=1;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xce: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8|=2;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}

			case 0xd6: 

				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));

					work8|=4;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xde: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8|=8;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xe6: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8|=16;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xee: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8|=32;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xf6: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8|=64;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xfe: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8|=128;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}

				/* viklyuchenie bitov */
			case 0x86: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8&=0xfe;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0x8e: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8&=0xfd;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0x96: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));

					work8&=0xfb;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0x9e:
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8&=0xf7;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);


					break;
				}
			case 0xa6: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8&=0xef;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xae: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8&=0xdf;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xb6: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8&=0xbf;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xbe: 
				{
					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8&=0x7f;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);


					break;
				}

				/* poriverka bitov */
			case 0x40:
			case 0x41:
			case 0x42:
			case 0x43:
			case 0x44:
			case 0x45:
			case 0x47:	
			case 0x46: 
				{
					bit(io_readByte(IY+(signed char)io_readByte(PC+1)),0);							
					break;
				}
			case 0x48:
			case 0x49:
			case 0x4a:
			case 0x4b:
			case 0x4c:
			case 0x4d:
			case 0x4e:	
			case 0x4f: 
				{
					bit(io_readByte(IY+(signed char)io_readByte(PC+1)),1);							
					break;
				}
			case 0x56: 
				{
					bit(io_readByte(IY+(signed char)io_readByte(PC+1)),2);							
					break;
				}
			case 0x5e: 
				{
					bit(io_readByte(IY+(signed char)io_readByte(PC+1)),3);							
					break;
				}
			case 0x66: 
				{
					bit(io_readByte(IY+(signed char)io_readByte(PC+1)),4);							
					break;
				}
			case 0x6e: 
				{
					bit(io_readByte(IY+(signed char)io_readByte(PC+1)),5);							
					break;
				}

			case 0x76: 
				{
					bit(io_readByte(IY+(signed char)io_readByte(PC+1)),6);							
					break;
				}
			case 0x7e: 
				{
					bit(io_readByte(IY+(signed char)io_readByte(PC+1)),7);							
					break;
				}

			case 0x3e: /* srl (iy+s) */


				{
					myFflagC_s( io_readByte(IY+(signed char)io_readByte(PC+1)) & 0x01);                                                                  

					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8>>=1;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);

					znak(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IY+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IY+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x0e: /* rrc (iy+s) */
				{
					myFflagC_s( io_readByte(IY+(signed char)io_readByte(PC+1)) & 0x01);                                                                  

					io_writeByte(IY+(signed char)io_readByte(PC+1), (io_readByte(IY+(signed char)io_readByte(PC+1)) >> 1) | (myFflagC_r() * 128));                                   

					znak(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IY+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IY+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x26: /* sla (iy+s) */
				{  
					myFflagC_s( ((io_readByte(IY+(signed char)io_readByte(PC+1)) & 0x80) != 0));                                                 

					work8=io_readByte(IY+(signed char)io_readByte(PC+1));
					work8<<=1;
					io_writeByte(IY+(signed char)io_readByte(PC+1),work8);


					znak(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IY+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IY+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x1e: /* rr (iy+s) */
				{
					work8 = io_readByte(IY+(signed char)io_readByte(PC+1)) & 0x01;                                                                 
					io_writeByte(IY+(signed char)io_readByte(PC+1),(io_readByte(IY+(signed char)io_readByte(PC+1)) >> 1) | (myFflagC_r() * 128));                                   
					myFflagC_s( work8);

					znak(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IY+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IY+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x06: /* rlc (iy+s) */
				{
					myFflagC_s( ((io_readByte(IY+(signed char)io_readByte(PC+1)) & 0x80) != 0));                                                 
					io_writeByte(IY+(signed char)io_readByte(PC+1),(io_readByte(IY+(signed char)io_readByte(PC+1)) << 1) | myFflagC_r());

					znak(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IY+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IY+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x16: /* rl (iy+s) */
				{
					work8 = ((io_readByte(IY+(signed char)io_readByte(PC+1)) & 0x80) != 0);                                                
					io_writeByte(IY+(signed char)io_readByte(PC+1), ((io_readByte(IY+(signed char)io_readByte(PC+1)) << 1) | myFflagC_r()));                                                  
					myFflagC_s( work8);
					znak(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IY+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IY+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x2e: /* sra (iy+s) */
				{
					myFflagC_s( io_readByte(IY+(signed char)io_readByte(PC+1)) & 0x01);                                                                  
					work8 = io_readByte(IY+(signed char)io_readByte(PC+1)) & 0x80;                                                                 
					io_writeByte(IY+(signed char)io_readByte(PC+1), ((io_readByte(IY+(signed char)io_readByte(PC+1)) >> 1) | work8));                                                 

					znak(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IY+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IY+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x0f:
				{
					A = io_readByte(IY+(signed char)io_readByte(PC+1));                                                        

					myFflagC_s( A & 0x01);                                                                  
					A= (A >> 1) | (myFflagC_r() * 128);                                   

					znak(A);                                                
					zero(A);
					parity(A);
					myFflagH_s(0);
					myFflagN_s(0);

					io_writeByte(IY+(signed char)io_readByte(PC+1), A); 

					break; 
				}	

			case 0x00:
				{
					B = io_readByte(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                                                   
					RLC(&B);                                                                                               
					io_writeByte(io_readByte(IY+(signed char)io_readByte(PC+1)), B);                                                                                    
					break;  
				}



			case 0x01:
				{
					C = io_readByte(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                                                   
					RLC(&C);                                                                                               
					io_writeByte(io_readByte(IY+(signed char)io_readByte(PC+1)), C);                                                                                    
					break;  
				}

			case 0x02:
				{
					D = io_readByte(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                                                   
					RLC(&D);                                                                                               
					io_writeByte(io_readByte(IY+(signed char)io_readByte(PC+1)), D);                                                                                    
					break;  
				}

			case 0x03:

				{
					E = io_readByte(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                                                   

					RLC(&E);                                                                                               
					io_writeByte(io_readByte(IY+(signed char)io_readByte(PC+1)), E);                                                                                    
					break;  
				}

			case 0x04:
				{
					H = io_readByte(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                                                   
					RLC(&H);                                                                                               
					io_writeByte(io_readByte(IY+(signed char)io_readByte(PC+1)), H);                                                                                    

					break;  
				}

			case 0x05:
				{
					L = io_readByte(io_readByte(IY+(signed char)io_readByte(PC+1)));                                                                                   
					RLC(&L);                                                                                               
					io_writeByte(io_readByte(IY+(signed char)io_readByte(PC+1)), L);                                                                                    
					break;  
				}

			default :
				printf("Z80 :  fd cb S %2x. Unknown. PC=%4x.\n",io_readByte(PC+2),PC-1);
				ExitWithError(-1,"");
			}

			PC+=3;
			return(23);
		}

	case 0xe5 : /* push iy */
		{
			push(IY);

			PC++;
			return(15);
		}

	case 0x96 : /* sub (iy+s) */
		{
			val=io_readByte(IY+(signed char)io_readByte(PC+1));	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              

			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4) );                                    

			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC+=2;
			return(19);
		}

	case 0xe1 : /* pop iy */
		{
			pop(&IY);

			PC++;
			return(14);
		}

	case 0x8e: /* adc a,(iy+s) */
		{
			val=io_readByte(IY+(signed char)io_readByte(PC+1));

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;

			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC+=2;
			return(19);
		}

	case 0xe3 : /* ex (sp),iy */

		{
			pop(&XX);
			push(IY);
			IY=XX;

			PC++;
			return(23);
		}


		/* operatsii s polovinkami IY start */

	case 0x24: /* inc IYh   */
		{
			IYh++;

			znak(IYh);                                                 
			zero(IYh);                                                                  
			myFflagH_s(   (((IYh) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((IYh) == 0x80));                                                               


			myFflagN_s(0);

			PC++;
			return(8);                                                              
		}	


	case 0x25:   /* dec IYh */
		{
			IYh--;


			znak(IYh);
			zero(IYh);
			myFflagPV_s((IYh==0x7f));
			myFflagN_s(1);
			myFflagH_s(    ((IYh&0x0f)==0x0f));

			PC++;
			return(8); 
		}

	case 0x26: 
		{
			IYh=io_readByte(PC+1);

			PC+=2;
			return(11);
		}

	case 0x2c: /* inc IYl   */
		{
			IYl++;

			znak(IYl);                                                 
			zero(IYl);                                                                  
			myFflagH_s(   (((IYl) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((IYl) == 0x80));                                                               
			myFflagN_s(0);

			PC++;
			return(8);                                                              
		}	

	case 0x2d:   /* dec IYl */
		{
			IYl--;

			znak(IYl);
			zero(IYl);
			myFflagPV_s((IYl==0x7f));
			myFflagN_s(1);
			myFflagH_s(    ((IYl&0x0f)==0x0f));

			PC++;
			return(8); 
		}

	case 0x2e: 
		{
			IYl=io_readByte(PC+1);

			PC+=2;
			return(11);
		}

	case 0x44:    
		{
			B=IYh;

			PC++;
			return(8);
		}

	case 0x45:    
		{
			B=IYl;

			PC++;
			return(8);
		}	

	case 0x4c:    
		{
			C=IYh;

			PC++;
			return(8);
		}

	case 0x4d:    
		{
			C=IYl;

			PC++;
			return(8);
		}	

	case 0x54:    
		{
			D=IYh;

			PC++;
			return(8);
		}

	case 0x55:    
		{
			D=IYl;

			PC++;
			return(8);
		}	

	case 0x5c:    
		{
			E=IYh;

			PC++;
			return(8);
		}

	case 0x5d:    
		{
			E=IYl;

			PC++;
			return(8);
		}	

	case 0x60:    
		{
			IYh=B;

			PC++;
			return(8);
		}	

	case 0x61:    
		{
			IYh=C;

			PC++;
			return(8);
		}	

	case 0x62:    
		{
			IYh=D;

			PC++;
			return(8);
		}	

	case 0x63:    
		{
			IYh=E;

			PC++;
			return(8);
		}	

	case 0x64:    
		{
			IYh=IYh;

			PC++;
			return(8);
		}	

	case 0x65:    
		{
			IYh=IYl;

			PC++;
			return(8);
		}	


	case 0x67:    
		{
			IYh=A;

			PC++;
			return(8);
		}	


	case 0x68:    
		{
			IYl=B;

			PC++;
			return(8);
		}	

	case 0x69:    
		{
			IYl=C;

			PC++;
			return(8);
		}	

	case 0x6a:    
		{
			IYl=D;

			PC++;
			return(8);
		}	

	case 0x6b:    
		{
			IYl=E;

			PC++;
			return(8);
		}	

	case 0x6c:    
		{
			IYl=IYh;

			PC++;
			return(8);
		}	

	case 0x6d:    
		{
			IYl=IYl;

			PC++;
			return(8);
		}	

	case 0x6f:    
		{
			IYl=A;

			PC++;
			return(8);
		}

	case 0x7c:    

		{
			A=IYh;

			PC++;
			return(8);
		}


	case 0x7d:    
		{
			A=IYl;

			PC++;
			return(8);
		}

	case 0x84:
		{
			val=IYh;

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);	
		}

	case 0x85:
		{
			val=IYl;

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 

			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);	
		}

	case 0x8c:
		{
			val=IYh;

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);
		}

	case 0x8d:
		{
			val=IYl;

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);
		}

	case 0x94 :
		{
			val=IYh;	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);
		}

	case 0x95 :
		{
			val=IYl;	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);
		}

	case 0x9c:
		{
			val=IYh;

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);
		}

	case 0x9d:
		{
			val=IYl;

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));


			PC++;
			return(8);
		}

	case 0xa4:


		{
			A=A&IYh;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	case 0xa5:
		{
			A=A&IYl;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	case 0xac:

		{
			A=A^IYh;


			ParityA;




			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	case 0xad:
		{
			A=A^IYl;

			ParityA;

			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	case 0xb4:
		{
			A=A|IYh;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	case 0xb5:
		{
			A=A|IYl;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	case 0xbc:
		{	
			val=IYh;



			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);
		}

	case 0xbd:
		{	
			val=IYl;

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(8);
		}

	case 0x3b: /* dec SP */
		{
			SP--;

			PC++;
			return(10);
		}

	case 0xbf: /* NOP */
		{	

			PC++;
			return(8);
		}

	case 0xaf: /* NOP */
		{

			PC++;
			return(8);
		}	

	default :
		return(z80a(0)+4);
	}

	printf("\nZ80 : Unknown instruction fd%x at address %x.\n",io_readByte(PC),PC-1);
	ExitWithError(-1,"");
}


int DD (void)
{
	switch(io_readByte(PC))
	{

	case 0x21: /*ld ix, nn*/
		{
			io_writeToRamAddrSpAddr((unsigned char *)&IX,PC+1);
			PC+=3;
			return(14);
		}

	case 0xf9: /*ld sp, ix*/
		{
			SP=IX;
			PC++;
			return(10);
		}

	case 0x5b: /* ld de, (nn) */
		{
			E=io_readByte(ex(io_readByte(PC+2),io_readByte(PC+1)));
			D=io_readByte(ex(io_readByte(PC+2),io_readByte(PC+1))+1);
			PC+=3;
			return(20);
		}

	case 0x2a: /* ld ix, (nn) */
		{
			io_writeToRamAddrSpAddr((unsigned char *)&IX, ex(io_readByte(PC+2),io_readByte(PC+1)));
			PC+=3;
			return(20);
		}

	case 0x22: /* ld (nn), ix */
		{
			io_writeToSpAddrVal(ex(io_readByte(PC+2),io_readByte(PC+1)),IX);
			PC+=3;
			return(20);
		}

		/* zagruzka registrov iz pamyati indexnoy adresatsiei */

	case 0x7e: 
		{
			A=io_readByte(IX+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

	case 0x66: 
		{
			H=io_readByte(IX+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

	case 0x6e: 
		{
			L=io_readByte(IX+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

	case 0x46: 
		{

			B=io_readByte(IX+(signed char)io_readByte(PC+1));

			PC+=2;
			return(19);
		}

	case 0x4e: 
		{

			C=io_readByte(IX+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

	case 0x56: 
		{
			D=io_readByte(IX+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

	case 0x5e: 
		{
			E=io_readByte(IX+(signed char)io_readByte(PC+1));
			PC+=2;
			return(19);
		}

		/* zapis' v pamyat' indexnoy adresatsiei */

	case 0x77: 
		{
			io_writeByte(IX+(signed char)io_readByte(PC+1),A);
			PC+=2;
			return(19);
		}

	case 0x74: 

		{
			io_writeByte(IX+(signed char)io_readByte(PC+1),H);
			PC+=2;
			return(19);
		}

	case 0x75: 
		{
			io_writeByte(IX+(signed char)io_readByte(PC+1),L);
			PC+=2;
			return(19);
		}

	case 0x70: 
		{
			io_writeByte(IX+(signed char)io_readByte(PC+1),B);
			PC+=2;
			return(19);
		}

	case 0x71: 
		{
			io_writeByte(IX+(signed char)io_readByte(PC+1),C);
			PC+=2;
			return(19);

		}

	case 0x72: 
		{
			io_writeByte(IX+(signed char)io_readByte(PC+1),D);
			PC+=2;
			return(19);
		}

	case 0x73: 
		{
			io_writeByte(IX+(signed char)io_readByte(PC+1),E);
			PC+=2;
			return(19);
		}

	case 0x36: 
		{
			io_writeByte(IX+(signed char)io_readByte(PC+1),io_readByte(PC+2));

			PC+=3;
			return(19);
		}

	case 0xa6: /* and (ix+s) */
		{
			A=A&(io_readByte(IX+(signed char)io_readByte(PC+1)));

			ParityA;

			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC+=2;
			return(19);
		}	


	case 0xb6: /* or (ix+s) */
		{
			A=A|(io_readByte(IX+(signed char)io_readByte(PC+1)));

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC+=2;
			return(19);

		}	

	case 0xae: /* xor (ix+s) */
		{
			A=A^(io_readByte(IX+(signed char)io_readByte(PC+1)));

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC+=2;
			return(19);
		}	

	case 0xe9: /* jp (ix) */
		{
			PC=IX;
			return(8);
		}

	case 0x35: /* dec (ix+s) */
		{
			work8=io_readByte(IX+(signed char)io_readByte(PC+1));
			work8--;
			io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

			znak(io_readByte(IX+(signed char)io_readByte(PC+1)));
			zero(io_readByte(IX+(signed char)io_readByte(PC+1)));
			myFflagPV_s((io_readByte(IX+(signed char)io_readByte(PC+1))==0x7f));
			myFflagN_s(1);

			/* !!! */ 				
			/* myF.flagH=((io_readByte(IX+(signed char)io_readByte(PC+1))&0x0f)==0x0f); */

			PC+=2;
			return(23);
		}

	case 0x2b: /* dec ix */
		{
			IX--;
			PC++;
			return(10);
		}

	case 0xbe: /* cp (ix+s) */
		{	
			val=io_readByte(IX+(signed char)io_readByte(PC+1));

			work16 = A - (val);                                                                             

			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    

			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC+=2;
			return(19);
		}

	case 0x9e: /*sbc a, (ix+s) */
		{
			val=io_readByte(IX+(signed char)io_readByte(PC+1));

			work16 = A - (val) - myFflagC_r();                                                    

			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC+=2;


			return(19);
		}

	case 0x86: /* add a, (ix+s) */
		{
			val=io_readByte(IX+(signed char)io_readByte(PC+1));

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               

				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;       

			// Ispravil ?
			//myFflagH_s(   hcarry_tbl(idx & 0x7));                                                

			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC+=2;
			return(19);
		}


		/* komandi prostogo slojeniya */


	case 0x29:
		{
			reg=IX;
			XX=IX;

			work32 = XX + (reg);                                            
			idx = ((XX & 0x0800) >> 9) |                                    
				(((reg) & 0x0800) >> 10) |                            
				((work32 & 0x0800) >> 11);                            
			XX = work32 & 0xffff;                                           
			myFflagH_s(   hcarry_tbl(idx));                                     
			myFflagN_s(0);                                                    
			myFflagC_s( ((work32 & 0x10000) != 0));  
			IX=XX;

			PC++;
			return(15);
		}

	case 0x09:
		{
			reg=BC;
			XX=IX;


			work32 = XX + (reg);                                            
			idx = ((XX & 0x0800) >> 9) |                                    
				(((reg) & 0x0800) >> 10) |                            
				((work32 & 0x0800) >> 11);                            
			XX = work32 & 0xffff;                                           
			myFflagH_s(   hcarry_tbl(idx));                                     
			myFflagN_s(0);                                                    
			myFflagC_s( ((work32 & 0x10000) != 0));  
			IX=XX;

			PC++;
			return(15);
		}

	case 0x19:
		{
			reg=DE;
			XX=IX;

			work32 = XX + (reg);                                            
			idx = ((XX & 0x0800) >> 9) |                                    
				(((reg) & 0x0800) >> 10) |                            
				((work32 & 0x0800) >> 11);                            
			XX = work32 & 0xffff;                                           
			myFflagH_s(   hcarry_tbl(idx));                                     
			myFflagN_s(0);                                                    
			myFflagC_s( ((work32 & 0x10000) != 0));  
			IX=XX;

			PC++;
			return(15);
		}

	case 0x39:
		{
			reg=SP;
			XX=IX;

			work32 = XX + (reg);                                            
			idx = ((XX & 0x0800) >> 9) |                                    
				(((reg) & 0x0800) >> 10) |                            
				((work32 & 0x0800) >> 11);                            
			XX = work32 & 0xffff;                                           
			myFflagH_s(   hcarry_tbl(idx));                                     
			myFflagN_s(0);                                                    
			myFflagC_s( ((work32 & 0x10000) != 0));  
			IX=XX;

			PC++;
			return(15);
		}

	case 0x34 : /* inc (ix+s) */
		{
			reg=io_readByte(IX+(signed char)io_readByte(PC+1));

			reg++;                                                                                                
			znak(reg);                                                 
			zero(reg);                                                                  
			myFflagH_s(   (((reg) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((reg) == 0x80));                                                               
			myFflagN_s(0);
			io_writeByte(IX+(signed char)io_readByte(PC+1),reg);

			PC+=2;
			return(23);
		}

	case 0x23 : /* inc ix */
		{

			IX++;

			PC++;
			return(10);
		}

	case 0xcb :  
		{
			/* R+=2; */

			switch(io_readByte(PC+2))
			{    
				/* vklyuchenie bitov **/
			case 0xc6: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8|=1;

					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xce: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8|=2;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xd6: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8|=4;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);


					break;
				}
			case 0xde: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8|=8;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xe6: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8|=16;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xee: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8|=32;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xf6: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8|=64;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xfe: 
				{

					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8|=128;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}

				/* viklyuchenie bitov */
			case 0x86: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8&=0xfe;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0x8e: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8&=0xfd;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0x96: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8&=0xfb;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0x9e: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8&=0xf7;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);


					break;
				}
			case 0xa6: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8&=0xef;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xae: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8&=0xdf;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}

			case 0xb6: 
				{

					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8&=0xbf;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}
			case 0xbe: 
				{
					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8&=0x7f;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					break;
				}

				/* proverka bitov */
			case 0x40:
			case 0x41:
			case 0x42:
			case 0x43:
			case 0x44:
			case 0x45:
			case 0x47:
			case 0x46:
				{
					bit(io_readByte(IX+(signed char)io_readByte(PC+1)),0);							
					break;
				}
			case 0x48:
			case 0x49:
			case 0x4a:
			case 0x4b:
			case 0x4c:
			case 0x4d:
			case 0x4e:	
			case 0x4f: 
				{
					bit(io_readByte(IX+(signed char)io_readByte(PC+1)),1);							
					break;
				}
			case 0x56: 
				{
					bit(io_readByte(IX+(signed char)io_readByte(PC+1)),2);							
					break;
				}
			case 0x5e: 
				{
					bit(io_readByte(IX+(signed char)io_readByte(PC+1)),3);							
					break;
				}
			case 0x66: 
				{
					bit(io_readByte(IX+(signed char)io_readByte(PC+1)),4);							
					break;
				}
			case 0x6e: 
				{
					bit(io_readByte(IX+(signed char)io_readByte(PC+1)),5);							
					break;

				}
			case 0x76: 
				{
					bit(io_readByte(IX+(signed char)io_readByte(PC+1)),6);							
					break;
				}
			case 0x7e: 
				{
					bit(io_readByte(IX+(signed char)io_readByte(PC+1)),7);							
					break;
				}

			case 0x3e: /* srl (ix+s) */
				{
					myFflagC_s( io_readByte(IX+(signed char)io_readByte(PC+1)) & 0x01);                                                                  

					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8>>=1;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					znak(io_readByte(IX+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IX+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IX+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x0e: /* rrc (ix+s) */
				{
					myFflagC_s( io_readByte(IX+(signed char)io_readByte(PC+1)) & 0x01);                                                                  
					io_writeByte(IX+(signed char)io_readByte(PC+1),((io_readByte(IX+(signed char)io_readByte(PC+1)) >> 1) | (myFflagC_r() * 128)));                                   

					znak(io_readByte(IX+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IX+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IX+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x26: /*sla (ix+s)*/
				{  
					myFflagC_s( ((io_readByte(IX+(signed char)io_readByte(PC+1)) & 0x80) != 0));                                                 

					work8=io_readByte(IX+(signed char)io_readByte(PC+1));
					work8<<=1;
					io_writeByte(IX+(signed char)io_readByte(PC+1),work8);

					znak(io_readByte(IX+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IX+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IX+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x1e: /*rr (ix+s) */
				{
					work8 = io_readByte(IX+(signed char)io_readByte(PC+1)) & 0x01;                                                                 
					io_writeByte(IX+(signed char)io_readByte(PC+1), ((io_readByte(IX+(signed char)io_readByte(PC+1)) >> 1) | (myFflagC_r() * 128)));                                   
					myFflagC_s( work8 );

					znak(io_readByte(IX+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IX+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IX+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;

				}

			case 0x06: /*rlc (ix+s)*/
				{
					myFflagC_s( ((io_readByte(IX+(signed char)io_readByte(PC+1)) & 0x80) != 0) );                                                 
					io_writeByte(IX+(signed char)io_readByte(PC+1), ((io_readByte(IX+(signed char)io_readByte(PC+1)) << 1) | myFflagC_r()));

					znak(io_readByte(IX+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IX+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IX+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x16: /* rl (ix+s) */
				{
					work8 = ((io_readByte(IX+(signed char)io_readByte(PC+1)) & 0x80) != 0);                                                
					io_writeByte(IX+(signed char)io_readByte(PC+1), ((io_readByte(IX+(signed char)io_readByte(PC+1)) << 1) | myFflagC_r()));                                                  
					myFflagC_s( work8);
					znak(io_readByte(IX+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IX+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IX+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x2e: /* sra (ix+s) */
				{
					myFflagC_s( io_readByte(IX+(signed char)io_readByte(PC+1)) & 0x01);                                                                  
					work8 = io_readByte(IX+(signed char)io_readByte(PC+1)) & 0x80;                                                                 
					io_writeByte(IX+(signed char)io_readByte(PC+1), ((io_readByte(IX+(signed char)io_readByte(PC+1)) >> 1) | work8));                                                 

					znak(io_readByte(IX+(signed char)io_readByte(PC+1)));                                                
					zero(io_readByte(IX+(signed char)io_readByte(PC+1)));
					parity(io_readByte(IX+(signed char)io_readByte(PC+1)));
					myFflagH_s(0);
					myFflagN_s(0);

					break;
				}

			case 0x0f:
				{
					A = io_readByte(IX+(signed char)io_readByte(PC+1));                                                        

					myFflagC_s( A & 0x01 );                                                                  
					A= (A >> 1) | (myFflagC_r() * 128);                                   

					znak(A);                                                
					zero(A);
					parity(A);
					myFflagH_s(0);
					myFflagN_s(0);

					io_writeByte(IX+(signed char)io_readByte(PC+1), A); 

					break; 
				}	

			default :
				printf("Z80 :  dd cb S %2x. Unknown. PC=%4x.\n",io_readByte(PC+2),PC-1);
				ExitWithError(-1,"");
			}

			PC+=3;
			return(23);
		}

	case 0xe5 : /* push ix */
		{
			push(IX);
			PC++;
			return(15);
		}

	case 0x96 : /* sub (ix+s) */
		{
			val=io_readByte(IX+(signed char)io_readByte(PC+1));	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC+=2;
			return(19);
		}

	case 0xe1 : /* pop ix */
		{
			pop(&IX);

			PC++;
			return(14);
		}

	case 0x8e: /*adc a,(ix+s) */
		{
			val=io_readByte(IX+(signed char)io_readByte(PC+1));

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC+=2;
			return(19);
		}

	case 0xe3 : /* ex (sp),ix */
		{
			pop(&XX);
			push(IX);

			IX=XX;

			PC++;
			return(23);
		}


		/* operatsii s polovinkami IX start */

	case 0x24: /*  inc IXh   */
		{
			IXh++;

			znak(IXh);                                                 
			zero(IXh);                                                                  
			myFflagH_s(   (((IXh) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((IXh) == 0x80));                                                               
			myFflagN_s(0);

			PC++;
			return(8);                                                              
		}	

	case 0x25:   /* dec IXh */
		{
			IXh--;

			znak(IXh);
			zero(IXh);
			myFflagPV_s((IXh==0x7f));
			myFflagN_s(1);
			myFflagH_s(    ((IXh&0x0f)==0x0f));

			PC++;
			return(8); 
		}


	case 0x26: 
		{
			IXh=io_readByte(PC+1);

			PC+=2;
			return(11);
		}

	case 0x2c: /* inc IXl   */
		{
			IXl++;


			znak(IXl);                                                 
			zero(IXl);                                                                  
			myFflagH_s(   (((IXl) & 0x0f) == 0));                                                 
			myFflagPV_s(   ((IXl) == 0x80));                                                               
			myFflagN_s(0);

			PC++;
			return(8);                                                              
		}	

	case 0x2d:   /* dec IXl */
		{
			IXl--;

			znak(IXl);
			zero(IXl);
			myFflagPV_s((IXl==0x7f));
			myFflagN_s(1);
			myFflagH_s(    ((IXl&0x0f)==0x0f));

			PC++;
			return(8); 
		}

	case 0x2e: 
		{
			IXl=io_readByte(PC+1);

			PC+=2;
			return(11);
		}

	case 0x44:    
		{
			B=IXh;

			PC++;
			return(8);
		}

	case 0x45:    

		{
			B=IXl;

			PC++;
			return(8);
		}	

	case 0x4c:    
		{
			C=IXh;

			PC++;
			return(8);

		}

	case 0x4d:    
		{
			C=IXl;

			PC++;
			return(8);
		}	

	case 0x54:    
		{
			D=IXh;

			PC++;
			return(8);
		}

	case 0x55:    
		{
			D=IXl;

			PC++;
			return(8);
		}	

	case 0x5c:    
		{
			E=IXh;

			PC++;
			return(8);
		}

	case 0x5d:    
		{
			E=IXl;

			PC++;
			return(8);
		}	

	case 0x60:    
		{
			IXh=B;


			PC++;
			return(8);
		}	

	case 0x61:    
		{
			IXh=C;

			PC++;
			return(8);
		}	

	case 0x62:    
		{
			IXh=D;

			PC++;
			return(8);
		}	

	case 0x63:    
		{
			IXh=E;

			PC++;
			return(8);
		}	

	case 0x64:    
		{
			IXh=IXh;

			PC++;
			return(8);
		}	


	case 0x65:    
		{
			IXh=IXl;

			PC++;
			return(8);
		}	

	case 0x67:    
		{
			IXh=A;

			PC++;
			return(8);
		}	


	case 0x68:    
		{
			IXl=B;

			PC++;
			return(8);

		}	


	case 0x69:    
		{
			IXl=C;

			PC++;
			return(8);
		}	

	case 0x6a:    
		{
			IXl=D;

			PC++;
			return(8);
		}	

	case 0x6b:    
		{
			IXl=E;

			PC++;
			return(8);
		}	

	case 0x6c:    
		{
			IXl=IXh;


			PC++;
			return(8);
		}	

	case 0x6d:    
		{
			IXl=IXl;

			PC++;

			return(8);
		}	

	case 0x6f:    
		{
			IXl=A;

			PC++;
			return(8);
		}

	case 0x7c:    
		{
			A=IXh;

			PC++;
			return(8);
		}

	case 0x7d:    
		{
			A=IXl;


			PC++;
			return(8);

		}

	case 0x84:
		{
			val=IXh;

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(8);	
		}

	case 0x85:
		{

			val=IXl;

			work16 = A + (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                              
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s(   overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(8);	
		}

	case 0x8c:
		{
			val=IXh;

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(8);
		}

	case 0x8d:
		{
			val=IXl;

			work16 = A + (val) + myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;
			myFflagH_s(   hcarry_tbl(idx & 0x7));                                                 
			myFflagPV_s( overflow_tbl(idx >> 4));                                                
			myFflagN_s(0);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(8);
		}

	case 0x94 :
		{
			val=IXh;	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       

			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);
		}

	case 0x95 :

		{
			val=IXl;	

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;                                                             
			ZeroA;                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);
		}

	case 0x9c:
		{
			val=IXh;

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);
		}

	case 0x9d:
		{
			val=IXl;

			work16 = A - (val) - myFflagC_r();                                                    
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			A = work16 & 0xff;                                                                              
			ZnakA;
			ZeroA;                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);
		}

	case 0xa4:
		{

			A=A&IXh;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);


			PC++;
			return(8);
		}	

	case 0xa5:
		{
			A=A&IXl;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	case 0xac:
		{
			A=A^IXh;

			ParityA;
			ZnakA;
			ZeroA;

			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	case 0xad:
		{
			A=A^IXl;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	case 0xb4:
		{
			A=A|IXh;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	case 0xb5:
		{
			A=A|IXl;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);


			PC++;
			return(8);
		}	

	case 0xbc:
		{	
			val=IXh;

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);

		}

	case 0xbd:
		{	
			val=IXl;

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);
		}

	case 0xbf:
		{	
			val=A;

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                                
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			PC++;
			return(8);
		}

	case 0xaf:
		{
			A=A^A;

			ParityA;
			ZnakA;
			ZeroA;
			myFflagC_s(0);
			myFflagH_s(0);
			myFflagN_s(0);

			PC++;
			return(8);
		}	

	default :
		return(z80a(0)+4);
	}

	printf("\nZ80 : Unknown instruction dd%x at address %x.\n",io_readByte(PC),PC-1);
	ExitWithError(-1,"");
}

int ED (void)
{
	switch(io_readByte(PC))
	{
	case 0x6b: /* ld hl, (nn) */
		{
			L=io_readByte(ex(io_readByte(PC+2),io_readByte(PC+1)));
			H=io_readByte(ex(io_readByte(PC+2),io_readByte(PC+1))+1);
			PC+=3;
			return(20);
		}

	case 0x7b: /* ld sp, (nn) */
		{
			io_writeToRamAddrSpAddr((unsigned char *)&SP, ex(io_readByte(PC+2),io_readByte(PC+1)));
			PC+=3;
			return(20);
		}

	case 0x4b: /* ld bc, (nn) */
		{
			C=io_readByte(ex(io_readByte(PC+2),io_readByte(PC+1)));
			B=io_readByte(ex(io_readByte(PC+2),io_readByte(PC+1))+1);
			PC+=3;
			return(20);
		}

	case 0x5b: /* ld de, (nn) */
		{
			E=io_readByte(ex(io_readByte(PC+2),io_readByte(PC+1)));
			D=io_readByte(ex(io_readByte(PC+2),io_readByte(PC+1))+1);
			PC+=3;
			return(20);
		}

	case 0x63: /* ld (nn), hl */
		{
			io_writeByte(ex(io_readByte(PC+2),io_readByte(PC+1)),L);
			io_writeByte(ex(io_readByte(PC+2),io_readByte(PC+1))+1,H);
			PC+=3;
			return(20);
		}

	case 0x73: /* ld (nn), sp */
		{
			io_writeToSpAddrVal(ex(io_readByte(PC+2),io_readByte(PC+1)),SP);
			PC+=3;
			return(20);
		}

	case 0x43: /* ld (nn),bc */
		{
			io_writeByte(ex(io_readByte(PC+2),io_readByte(PC+1)),C);
			io_writeByte(ex(io_readByte(PC+2),io_readByte(PC+1))+1,B);
			PC+=3;
			return(20);
		}

	case 0x53: /* ld (nn),de */
		{
			io_writeByte(ex(io_readByte(PC+2),io_readByte(PC+1)),E);
			io_writeByte(ex(io_readByte(PC+2),io_readByte(PC+1))+1,D);
			PC+=3;
			return(20);
		}

	case 0x47:
		{
			I=A; /* ld i,a */
			PC++;
			return(9);
		}

		/* komandi vichitania s uchetom perenosa */

	case 0x62:
		{
			reg=HL;

			work32 = HL - (reg) - myFflagC_r();                                                   
			idx = ((HL & 0x8800) >> 9) |                                                    
				(((reg) & 0x8800) >> 10) |                                            
				((work32 & 0x8800) >> 11);                                            
			HL1_1 = work32 & 0xffff;                                                                   
			myFflagS_s(   ((HL1_1 & 0x8000) != 0));                                                  
			myFflagZ_s(   (HL1_1 == 0));                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work32 & 0x10000) != 0));
			HL=HL1_1;

			PC++;
			return(15);
		}

	case 0x42:
		{
			reg=BC;

			work32 = HL - (reg) - myFflagC_r();                                                   
			idx = ((HL & 0x8800) >> 9) |                                                    
				(((reg) & 0x8800) >> 10) |                                            
				((work32 & 0x8800) >> 11);                                            
			HL1_1 = work32 & 0xffff;                                                                   
			myFflagS_s(   ((HL1_1 & 0x8000) != 0));                                                  
			myFflagZ_s(   (HL1_1 == 0));                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work32 & 0x10000) != 0));
			HL=HL1_1;

			PC++;
			return(15);
		}

	case 0x52:
		{
			reg=DE;

			work32 = HL - (reg) - myFflagC_r();                                                   
			idx = ((HL & 0x8800) >> 9) |                                                    
				(((reg) & 0x8800) >> 10) |                                            
				((work32 & 0x8800) >> 11);                                            
			HL1_1 = work32 & 0xffff;                                                                   
			myFflagS_s(   ((HL1_1 & 0x8000) != 0));                                                  
			myFflagZ_s(   (HL1_1 == 0));                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work32 & 0x10000) != 0));
			HL=HL1_1;

			PC++;
			return(15);
		}

	case 0x72:
		{
			reg=SP;

			work32 = HL - (reg) - myFflagC_r();                                                   
			idx = ((HL & 0x8800) >> 9) |                                                    
				(((reg) & 0x8800) >> 10) |                                            
				((work32 & 0x8800) >> 11);                                            
			HL1_1 = work32 & 0xffff;                                                                   
			myFflagS_s(   ((HL1_1 & 0x8000) != 0));                                                  
			myFflagZ_s(   (HL1_1 == 0));                                                                             
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);
			myFflagC_s( ((work32 & 0x10000) != 0));
			HL=HL1_1;

			PC++;
			return(15);
		}

	case 0xb8: /* lddr */
		{
			io_writeByte(DE,io_readByte(HL));
			BC--;

			HL--; DE--;

			if (!BC)
			{
				myFflagPV_s(0);
				myFflagH_s(0);
				myFflagN_s(0);
				PC++;
				return(16);
			}
			else
			{
				myFflagPV_s(1);
				myFflagH_s(0);
				myFflagN_s(0);
				PC--;
				return(21);
			}
		}

	case 0xa8: /* ldd */
		{
			io_writeByte(DE,io_readByte(HL));
			BC--;

			HL--; DE--;

			if (!BC)
				myFflagPV_s(0);
			else
				myFflagPV_s(1);

			myFflagH_s(0);
			myFflagN_s(0);
			PC++;
			return(16);
		}

	case 0xb0: /* ldir */
		{
			io_writeByte(DE,io_readByte(HL));
			BC--;

			HL++; DE++;

			if (!BC)
			{
				myFflagPV_s(0);
				myFflagH_s(0);
				myFflagN_s(0);
				PC++;
				return(16);
			}
			else
			{
				myFflagPV_s(1);
				myFflagH_s(0);
				myFflagN_s(0);			
				PC--;
				return(21);
			}
		}

	case 0xa0: /* ldi */
		{
			io_writeByte(DE,io_readByte(HL));
			BC--;

			HL++; DE++;

			if (!BC)
				myFflagPV_s(0);
			else
				myFflagPV_s(1);

			myFflagH_s(0);
			myFflagN_s(0);
			PC++;
			return(16);
		}

	case 0x56: /* im1 */
		{
			IM=1;

			PC++;
			return(8);
		}


		/* komandi vivoda na vneshnie ustroistva */

	case 0x79:
		{
			OutPort(C,B,A);
			PC+=1;
			return(12);
		}

	case 0x61:
		{
			OutPort(C,B,H);
			PC+=1;
			return(12);
		}

	case 0x69:
		{
			OutPort(C,B,L);
			PC+=1;
			return(12);
		}

	case 0x41:
		{
			OutPort(C,B,B);
			PC+=1;
			return(12);
		}

	case 0x49:
		{
			OutPort(C,B,C);
			PC+=1;
			return(12);
		}

	case 0x51:
		{
			OutPort(C,B,D);
			PC+=1;
			return(12);

		}

	case 0x59:
		{
			OutPort(C,B,E);
			PC+=1;
			return(12);
		}

		/* komandi vvoda ot vneshnih ystroistv */

	case 0x78: 
		{
			A=InPort(C,B);
			myFflagN_s(0);
			myFflagH_s(0);
			parity(A);
			zero(A);
			znak(A);

			PC+=1;
			return(12);
		}

	case 0x60: 
		{
			H=InPort(C,B);
			myFflagN_s(0);
			myFflagH_s(0);
			parity(H);
			zero(H);
			znak(H);

			PC+=1;
			return(12);
		}

	case 0x68: 
		{
			L=InPort(C,B);
			myFflagN_s(0);
			myFflagH_s(0);
			parity(L);
			zero(L);
			znak(L);

			PC+=1;
			return(12);
		}

	case 0x40: 
		{
			B=InPort(C,B);
			myFflagN_s(0);
			myFflagH_s(0);
			parity(B);
			zero(B);
			znak(B);


			PC+=1;
			return(12);
		}

	case 0x48: 
		{
			C=InPort(C,B);
			myFflagN_s(0);
			myFflagH_s(0);
			parity(C);
			zero(C);
			znak(C);

			PC+=1;
			return(12);
		}

	case 0x50: 
		{
			D=InPort(C,B);
			myFflagN_s(0);
			myFflagH_s(0);
			parity(D);
			zero(D);
			znak(D);

			PC+=1;

			return(12);
		}

	case 0x58: 
		{
			E=InPort(C,B);
			myFflagN_s(0);
			myFflagH_s(0);
			parity(E);
			zero(E);
			znak(E);

			PC+=1;
			return(12);
		}




	case 0x70: 
		{
			F=InPort(C,B);
			myFflagN_s(0);
			myFflagH_s(0);
			parity(F);
			zero(F);
			znak(F);

			PC+=1;
			return(12);
		}

		/* komandi slojeniya s uchetom prenosa */

	case 0x6a:
		{
			reg=HL;
			HL1_1=HL;

			work32 = HL1_1 + reg + myFflagC_r();							
			idx = ((HL1_1 & 0x8800) >> 9) |							
				((reg & 0x8800) >> 10) |						
				((work32 & 0x8800) >> 11);						
			HL1_1 = work32 & 0xffff;									
			myFflagS_s(   ((HL1_1 & 0x8000) != 0));							
			myFflagZ_s( (HL1_1 == 0) );										
			myFflagH_s(   hcarry_tbl(idx & 0x7));							
			myFflagPV_s( overflow_tbl(idx >> 4));						
			myFflagN_s(0);											
			myFflagC_s( ((work32 & 0x10000) != 0) );		
			HL=HL1_1;

			PC++;
			return(15);
		}

	case 0x4a:
		{
			reg=BC;
			HL1_1=HL;

			work32 = HL1_1 + reg + myFflagC_r();							
			idx = ((HL1_1 & 0x8800) >> 9) |							
				((reg & 0x8800) >> 10) |						
				((work32 & 0x8800) >> 11);						
			HL1_1 = work32 & 0xffff;									
			myFflagS_s(   ((HL1_1 & 0x8000) != 0));
			myFflagZ_s( (HL1_1 == 0) );										
			myFflagH_s(   hcarry_tbl(idx & 0x7));							
			myFflagPV_s( overflow_tbl(idx >> 4));						
			myFflagN_s(0);											
			myFflagC_s( ((work32 & 0x10000) != 0) );		
			HL=HL1_1;

			PC++;
			return(15);
		}

	case 0x5a:
		{
			reg=DE;
			HL1_1=HL;

			work32 = HL1_1 + reg + myFflagC_r();							
			idx = ((HL1_1 & 0x8800) >> 9) |							
				((reg & 0x8800) >> 10) |						
				((work32 & 0x8800) >> 11);						
			HL1_1 = work32 & 0xffff;									
			myFflagS_s(   ((HL1_1 & 0x8000) != 0));							
			myFflagZ_s( (HL1_1 == 0) );										
			myFflagH_s(   hcarry_tbl(idx & 0x7));							
			myFflagPV_s( overflow_tbl(idx >> 4) );						

			myFflagN_s(0);											

			myFflagC_s( ((work32 & 0x10000) != 0) );		
			HL=HL1_1;

			PC++;
			return(15);
		}

	case 0x7a:
		{

			reg=SP;
			HL1_1=HL;

			work32 = HL1_1 + reg + myFflagC_r();							
			idx = ((HL1_1 & 0x8800) >> 9) |							
				((reg & 0x8800) >> 10) |
				((work32 & 0x8800) >> 11);						
			HL1_1 = work32 & 0xffff;									
			myFflagS_s(   ((HL1_1 & 0x8000) != 0));							
			myFflagZ_s( (HL1_1 == 0) );										
			myFflagH_s(   hcarry_tbl(idx & 0x7));							
			myFflagPV_s( overflow_tbl(idx >> 4) );						
			myFflagN_s(0);											
			myFflagC_s( ((work32 & 0x10000) != 0) );		
			HL=HL1_1;


			PC++;
			return(11);
		}

	case 0x5f: /* ld a,r */
		{
			A=(R&0x7f) | (R7&0x80);

			myFflagPV_s(interrupts);

			ZnakA;
			ZeroA;

			myFflagN_s(0);
			myFflagH_s(0);

			PC++;
			return(9);
		}


	case 0x4d: /* reti */
	case 0x5d:
	case 0x6d:
	case 0x7d:
		{
			pop(&PC);
			/* interrupts=on; */
			return(14);
		}

	case 0x75:
	case 0x55:
	case 0x65:
	case 0x45: /* retn */
		{
			pop(&PC);
			/* interrupts=on; */
			return(14);
		}

	case 0xb9: /* cpdr */
		{
			val = io_readByte(HL);

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                               
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4) );                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			HL--; BC--;

			myFflagPV_s(   (BC != 0));

			if ((F&4) && (!(F&64)))
			{
				PC --;
				return(21);
			}

			PC++;

			return(16);
		}

	case 0xb1: /* cpir */
		{
			val = io_readByte(HL);

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       
			myFflagS_s(   ((work16 & 0x80) != 0));                                               
			myFflagZ_s(   ((work16 & 0xff) == 0));                                                
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                    
			myFflagC_s( ((work16 & 0x0100) != 0));

			HL++; BC--;

			myFflagPV_s (BC != 0);

			if ((F&4) && (!(F&64)))
			{
				PC --;
				return(21);
			}

			PC++;
			return(16);
		}

	case 0x44 : /* neg */

	case 0x4c:     /* undocummented (from xzx)*/
	case 0x54:     /* undocummented (from xzx) */
	case 0x5c:     /* undocummented (from xzx) */
	case 0x64:     /* undocummented (from xzx) */
	case 0x6c:     /* undocummented (from xzx)*/
	case 0x74:     /* undocummented (from xzx)*/
	case 0x7c:     /* undocummented (from xzx) */
		{
			work8 = A;
			A = 0;
			val=work8;

			work16 = A - (val);                                                                             
			idx = ((A & 0x88) >> 1) |                                                               
				(((val) & 0x88) >> 2) |                                                       
				((work16 & 0x88) >> 3);                                                       

			A = work16 & 0xff;                                                                              
			myFflagS_s(   ((A & 0x80) != 0));                                                             
			myFflagZ_s(   (A == 0));                                                                              
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                             
			myFflagPV_s(   sub_overflow_tbl(idx >> 4));                                    
			myFflagN_s(1);                                                                                   
			myFflagC_s( ((work16 & 0x0100) != 0) );

			PC++;
			return(8);
		}

	case 0x5e : /* im2 */
	case 0x7e :
		{
			IM=2;

			PC++;
			return(8);
		}

	case 0x6f: /* rld */
		{
			work8 = io_readByte(HL);
			io_writeByte(HL,((work8 << 4) | (A & 0x0f)));
			A = (A & 0xf0) | (work8 >> 4);
			myFflagS_s( ((A & 0x80) != 0) );
			ZeroA;
			myFflagH_s(0);
			ParityA;
			myFflagN_s(0);

			PC++;
			return(18);
		}	

	case 0x57 : /* ld a,i */
		{
			A=I;
			ZnakA;
			ZeroA;
			myFflagH_s(0);
			myFflagPV_s(interrupts); /* !!! */
			myFflagN_s(0);

			PC++;
			return(9);
		}


	case 0xab:
		{
			B--;  
			OutPort(C,B,io_readByte(HL));

			HL--;

			myFflagZ_s(   (B == 0));                                                       
			myFflagN_s(0);                                                             

			PC++;
			return(16);
		}	

	case 0x4f:
		{
			R7=R=A;

			PC++;
			return(9); 
		}




	case 0xa9: /* cpd */        
		{
			work8 = io_readByte(HL);                                                                      

			/* !cmp! */
			val=work8;

			work16 = A - val;                                                               
			idx = ((A & 0x88) >> 1) |                                                         
				(((val) & 0x88) >> 2) |                                                 
				((work16 & 0x88) >> 3);                                                 
			myFflagS_s( ((work16 & 0x80) != 0) );                                                
			myFflagZ_s( ((work16 & 0xff) == 0) );                                                 
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                            
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                            
			myFflagN_s(1);                                                                      
			myFflagC_s( ((work16 & 0x0100) != 0) ); 
			/* !cmp! */                                                                               

			HL--; BC--;

			myFflagPV_s(   (BC != 0));                                                                       


			PC++;
			return(16);
		}	

	case 0x67:  /* rrd */
		{
			work8 = io_readByte(HL);                                                                      
			io_writeByte(HL, ((work8 >> 4) | (A << 4)));                                                     
			A = (A & 0xf0) | (work8 & 0x0f);                                                          
			ZnakA;
			ZeroA;                                                                        
			ParityA;                                                                       
			myFflagH_s(0);  
			myFflagN_s(0);                                                                              

			PC++;
			return(18);
		}	

	case 0xa1:   /* cpi */
		{
			work8 = io_readByte(HL);                                                                      

			/* !cmp! */
			val=work8;

			work16 = A - val;                                                               
			idx = ((A & 0x88) >> 1) |                                                         
				(((val) & 0x88) >> 2) |                                                 
				((work16 & 0x88) >> 3);                                                 
			myFflagS_s( ((work16 & 0x80) != 0) );                                                
			myFflagZ_s( ((work16 & 0xff) == 0) );                                                 
			myFflagH_s(   sub_hcarry_tbl(idx & 0x7));                                            
			myFflagPV_s( sub_overflow_tbl(idx >> 4));                                            
			myFflagN_s(1);                                                                      
			myFflagC_s( ((work16 & 0x0100) != 0) ); 
			/* !cmp! */


			HL++; BC--;

			myFflagPV_s(   (BC != 0));                                                                       

			PC++;
			return(16);
		}

	case 0xa3:

		{
			B--;                                                                    
			OutPort(C,B,io_readByte(HL));
			HL++;                                                                   
			myFflagZ_s( (B == 0) );                                                      
			myFflagN_s(1);                                                            

			PC++;
			return(16);
		}

	case 0xa2:
		{
			io_writeByte(HL, InPort(C,B));

			B--; 
			HL++; 
			myFflagZ_s(   (B == 0));
			myFflagN_s(1);

			PC++;
			return(16);
		}

	case 0x46:
	case 0x4e:
	case 0x66:
	case 0x6e:
		{
			IM=0;

			PC++;
			return(8);
		}

	case 0x71:
		{
			OutPort(C,B,0);

			PC++;
			return(12);
		}

	case 0x00:
	case 0x01:
	case 0x02:
	case 0x03:
	case 0x04:
	case 0x05:
	case 0x06:
	case 0x07:
	case 0x08:
	case 0x09:
	case 0x0A:
	case 0x0B:
	case 0x0C:
	case 0x0D:
	case 0x0E:
	case 0x0F:

	case 0x10:
	case 0x11:
	case 0x12:
	case 0x13:
	case 0x14:
	case 0x15:
	case 0x16:
	case 0x17:
	case 0x18:
	case 0x19:
	case 0x1A:
	case 0x1B:
	case 0x1C:
	case 0x1D:
	case 0x1E:
	case 0x1F:

	case 0x20:
	case 0x21:
	case 0x22:
	case 0x23:
	case 0x24:
	case 0x25:
	case 0x26:
	case 0x27:
	case 0x28:
	case 0x29:
	case 0x2A:
	case 0x2B:
	case 0x2C:
	case 0x2D:
	case 0x2E:
	case 0x2F:

	case 0x30:
	case 0x31:
	case 0x32:
	case 0x33:
	case 0x34:
	case 0x35:
	case 0x36:
	case 0x37:
	case 0x38:
	case 0x39:
	case 0x3A:
	case 0x3B:
	case 0x3C:
	case 0x3D:
	case 0x3E:
	case 0x3F:

	case 0xBC:
	case 0xBD:
	case 0xBE:
	case 0xBF:

	case 0xC0:
	case 0xC1:
	case 0xC2:
	case 0xC3:
	case 0xC4:
	case 0xC5:
	case 0xC6:
	case 0xC7:
	case 0xC8:
	case 0xC9:
	case 0xCA:
	case 0xCB:
	case 0xCC:
	case 0xCD:
	case 0xCE:
	case 0xCF:

	case 0xD0:
	case 0xD1:
	case 0xD2:
	case 0xD3:
	case 0xD4:
	case 0xD5:
	case 0xD6:
	case 0xD7:
	case 0xD8:
	case 0xD9:
	case 0xDA:
	case 0xDB:
	case 0xDC:
	case 0xDD:
	case 0xDE:
	case 0xDF:

	case 0xE0:
	case 0xE1:
	case 0xE2:
	case 0xE3:
	case 0xE4:
	case 0xE5:
	case 0xE6:
	case 0xE7:
	case 0xE8:
	case 0xE9:
	case 0xEA:
	case 0xEB:
	case 0xEC:
	case 0xED:
	case 0xEE:
	case 0xEF:


	case 0xB4:
	case 0xB5:
	case 0xB6:
	case 0xB7:

	case 0xAC:
	case 0xAD:
	case 0xAE:
	case 0xAF:

	case 0xA4:
	case 0xA5:
	case 0xA6:
	case 0xA7:

	case 0x7F:

	case 0x80:
	case 0x81:
	case 0x82:
	case 0x83:
	case 0x84:
	case 0x85:
	case 0x86:
	case 0x87:
	case 0x88:
	case 0x89:
	case 0x8A:
	case 0x8B:
	case 0x8C:
	case 0x8D:
	case 0x8E:
	case 0x8F:

	case 0x90:
	case 0x91:
	case 0x92:
	case 0x93:
	case 0x94:
	case 0x95:
	case 0x96:
	case 0x97:
	case 0x98:
	case 0x99:
	case 0x9A:
	case 0x9B:
	case 0x9C:
	case 0x9D:
	case 0x9E:
	case 0x9F:

		{ /* NOP */

			PC++;
			return(8);
		}	
	}

	printf("\nZ80 : Unknown instruction ed%x at address %x.\n",io_readByte(PC),PC-1);
	ExitWithError(-1,"");

	return(0); /* eto chtob ne kvakalo */
}

